<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chances Game / SNL Economy Simulator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #0f172a;
      color: #e5e7eb;
    }

    h1,
    h2 {
      margin-top: 0;
      color: #facc15;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .card {
      background: #020617;
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
      border: 1px solid #1e293b;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
    }

    label {
      display: block;
      font-size: 13px;
      color: #9ca3af;
      margin-bottom: 4px;
    }

    .label-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    input[type="number"],
    input[type="text"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #334155;
      background: #020617;
      color: #e5e7eb;
      font-size: 14px;
      box-sizing: border-box;
    }

    input[type="number"]:focus,
    input[type="text"]:focus {
      outline: none;
      border-color: #38bdf8;
      box-shadow: 0 0 0 1px #38bdf8;
    }

    .button-row {
      margin-top: 16px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 10px 22px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #020617;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .btn-secondary {
      background: transparent;
      color: #e5e7eb;
      border: 1px solid #475569;
    }

    .btn-outline {
      background: transparent;
      color: #e5e7eb;
      border: 1px solid #38bdf8;
    }

    .small-text {
      font-size: 12px;
      color: #9ca3af;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      margin-top: 10px;
    }

    th,
    td {
      border: 1px solid #1f2937;
      padding: 6px 8px;
      text-align: right;
    }

    th {
      background: #020617;
      color: #e5e7eb;
      text-align: center;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    td:first-child,
    th:first-child {
      text-align: left;
    }

    .status {
      font-size: 13px;
      margin-top: 6px;
      color: #a5f3fc;
    }

    .error {
      color: #f97373;
    }

    .spinner {
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 2px solid #38bdf8;
      border-top-color: transparent;
      animation: spin 0.6s linear infinite;
      display: inline-block;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
      margin-top: 10px;
    }

    canvas {
      background: #020617;
      border-radius: 12px;
      padding: 8px;
    }

    select {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #334155;
      background: #020617;
      color: #e5e7eb;
      font-size: 13px;
    }

    .game-link-btn {
      background: transparent;
      border-radius: 999px;
      border: 1px solid #475569;
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
      color: #e5e7eb;
    }

    .game-link-btn:hover {
      border-color: #38bdf8;
    }

    /* --- BOARD (2x size, center) --- */
    .board-grid {
      display: grid;
      grid-template-columns: repeat(10, 64px);
      gap: 4px;
      margin-top: 8px;
      margin-left: auto;
      margin-right: auto;
      justify-content: center;
    }

    .board-cell {
      border-radius: 4px;
      border: 1px solid #1e293b;
      font-size: 11px;
      text-align: center;
      background: #020617;
      color: #6b7280;
      width: 64px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      padding: 0;
      box-sizing: border-box;
    }

    .board-cell.hit {
      background: #166534;
      color: #f9fafb;
      font-weight: 600;
    }

    .board-cell.hit span {
      display: block;
      font-size: 9px;
      color: #bbf7d0;
    }

    .board-tag {
      display: block;
      font-size: 9px;
      margin-top: 1px;
    }

    .board-arrow {
      display: block;
      font-size: 14px;
      line-height: 1;
      margin-top: 0;
    }

    .board-cell.snake-start,
    .board-cell.snake-end {
      background: #7f1d1d;
      color: #fee2e2;
      border-color: #fecaca;
    }

    .board-cell.ladder-start,
    .board-cell.ladder-end {
      background: #facc15;
      color: #4b2e0f;
      /* brown text */
      border-color: #fcd34d;
    }

    .board-cell.ladder-start.hit,
    .board-cell.ladder-end.hit {
      color: #4b2e0f;
    }

    .board-cell.ladder-start.hit span,
    .board-cell.ladder-end.hit span {
      color: #4b2e0f;
    }

    .game-visual-header {
      margin-top: 8px;
      margin-bottom: 4px;
      font-size: 12px;
      color: #e5e7eb;
    }

    .timeline {
      margin-top: 8px;
      max-height: 160px;
      overflow: auto;
      border-top: 1px solid #1e293b;
      padding-top: 6px;
    }

    .timeline-item {
      font-size: 12px;
      margin-bottom: 2px;
      color: #cbd5f5;
    }

    /* Dice paths */
    .dice-path {
      margin-top: 10px;
      border-top: 1px solid #1e293b;
      padding-top: 6px;
    }

    .dice-player-block {
      margin-top: 8px;
    }

    .dice-player-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 4px;
      color: #e5e7eb;
    }

    .dice-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      margin-top: 2px;
    }

    .dice-table th,
    .dice-table td {
      border: 1px solid #1f2937;
      padding: 4px 6px;
      text-align: center;
    }

    .dice-table th {
      background: #020617;
      position: static;
    }

    .dice-total-row td {
      font-weight: 600;
      background: #020617;
    }

    /* Info icon + tooltip */
    .info-icon {
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 1px solid #38bdf8;
      background: #020617;
      color: #e5e7eb;
      font-size: 10px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      cursor: pointer;
    }

    .info-icon:hover {
      background: #0f172a;
    }

    .tooltip {
      position: absolute;
      max-width: 280px;
      background: #020617;
      border-radius: 10px;
      border: 1px solid #38bdf8;
      padding: 10px 12px;
      font-size: 12px;
      color: #e5e7eb;
      box-shadow: 0 12px 25px rgba(0, 0, 0, 0.6);
      z-index: 9999;
    }

    .tooltip.hidden {
      display: none;
    }

    .tooltip-title {
      font-weight: 600;
      margin-bottom: 4px;
      color: #facc15;
    }

    .tooltip-close {
      position: absolute;
      top: 4px;
      right: 6px;
      border: none;
      background: transparent;
      color: #9ca3af;
      font-size: 12px;
      cursor: pointer;
    }

    /* progress text */
    .progress-text {
      font-size: 12px;
      color: #9ca3af;
      margin-left: 8px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Chances Game / SNL Economy Simulator</h1>
    <p class="small-text">
      Multiplayer Snakes &amp; Ladders economy with adaptive RTP, per-player dice bias and leaderboard pool.
    </p>

    <!-- CONFIG -->
    <div class="card">
      <h2>Configuration</h2>
      <div class="grid">
        <div>
          <label>
            <span class="label-row">
              <span>Entry Fee per Player</span>
              <button type="button" class="info-icon" data-title="Entry Fee per Player"
                data-info="Base amount each player pays to join a single game.&#10;&#10;Total entry for one game:&#10;TotalEntry = EntryFee × NumberOfPlayers.">
                i
              </button>
            </span>
          </label>
          <input id="entryFee" type="number" value="200" min="1" step="1" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>Players per Game (2–4)</span>
              <button type="button" class="info-icon" data-title="Players per Game"
                data-info="How many players join one instance of the game. Supported range: 2–4.&#10;&#10;TotalEntry = EntryFee × Players.&#10;Reward caps are also based on player count (2P=80%, 3P=70%, 4P=60%).">
                i
              </button>
            </span>
          </label>
          <input id="numPlayers" type="number" value="2" min="2" max="4" step="1" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>Base Admin % (normal)</span>
              <button type="button" class="info-icon" data-title="Base Admin %"
                data-info="Default admin margin used when players are not in heavy loss.&#10;&#10;Admin% decides how much of the total entry does NOT go to players as rewards.&#10;PlayerShare% = 100 – Admin%.">
                i
              </button>
            </span>
          </label>
          <input id="baseAdminPct" type="number" value="50" min="0" max="90" step="1" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>Medium-Loss Admin %</span>
              <button type="button" class="info-icon" data-title="Medium-Loss Admin %"
                data-info="Reduced admin margin when at least one player is in medium loss zone (recent window).&#10;&#10;This increases RTP and gives better comeback potential without going to maximum RTP.">
                i
              </button>
            </span>
          </label>
          <input id="midAdminPct" type="number" value="30" min="0" max="90" step="1" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>High-Loss Admin %</span>
              <button type="button" class="info-icon" data-title="High-Loss Admin %"
                data-info="Lowest admin margin used when one or more players are in heavy loss over the recent games.&#10;&#10;This mode gives very high RTP so that system can create strong recovery wins for retention and trust.">
                i
              </button>
            </span>
          </label>
          <input id="highAdminPct" type="number" value="10" min="0" max="90" step="1" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>Medium-Loss Threshold (× entry)</span>
              <button type="button" class="info-icon" data-title="Medium-Loss Threshold"
                data-info="Defines when a player enters MEDIUM LOSS zone based on recent net results.&#10;&#10;We track last N games (e.g. 20) per player.&#10;If recent loss ≥ MidLossMultiple × EntryFee, we switch to Mid-Loss Admin %.">
                i
              </button>
            </span>
          </label>
          <input id="midLossMultiple" type="number" value="3" min="0.5" step="0.5" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>High-Loss Threshold (× entry)</span>
              <button type="button" class="info-icon" data-title="High-Loss Threshold"
                data-info="Defines when a player enters HIGH LOSS zone based on recent net results.&#10;&#10;If recent loss ≥ HighLossMultiple × EntryFee, we switch to High-Loss Admin % (max RTP).">
                i
              </button>
            </span>
          </label>
          <input id="highLossMultiple" type="number" value="6" min="0.5" step="0.5" />
        </div>

        <!-- streak config -->
        <div>
          <label>
            <span class="label-row">
              <span>Loss Streak Size (games)</span>
              <button type="button" class="info-icon" data-title="Loss Streak Size"
                data-info="Number of consecutive games where a player must lose (or win very low) before the dice bias enters RECOVERY mode.&#10;&#10;Example: 3 → If a player has 3 bad games in a row, system starts helping them with more reward hits where possible.">
                i
              </button>
            </span>
          </label>
          <input id="lossStreakTrigger" type="number" value="3" min="1" step="1" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>Win Streak Size (games)</span>
              <button type="button" class="info-icon" data-title="Win Streak Size"
                data-info="Number of consecutive games with big wins before we consider a player as 'hot'.&#10;&#10;After this streak, system may slightly cool down dice for that player to avoid over-winning.">
                i
              </button>
            </span>
          </label>
          <input id="winStreakTrigger" type="number" value="3" min="1" step="1" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>Loss Game Threshold (× entry)</span>
              <button type="button" class="info-icon" data-title="Loss Game Threshold"
                data-info="Defines what is considered a 'loss game' for streak counting.&#10;&#10;If per-game net ≤ –LossGameMultiple × EntryFee, lossStreak++ for that player.">
                i
              </button>
            </span>
          </label>
          <input id="lossGameMultiple" type="number" value="0.5" min="0.1" step="0.1" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>Big Win Threshold (× entry)</span>
              <button type="button" class="info-icon" data-title="Big Win Threshold"
                data-info="Defines what is considered a 'big win' for streak counting.&#10;&#10;If per-game net ≥ BigWinMultiple × EntryFee, winStreak++ for that player.">
                i
              </button>
            </span>
          </label>
          <input id="bigWinMultiple" type="number" value="1.5" min="0.5" step="0.1" />
        </div>

        <!-- leaderboard from player share -->
        <div>
          <label>
            <span class="label-row">
              <span>Leaderboard Reserve % of Player Share</span>
              <button type="button" class="info-icon" data-title="Leaderboard Reserve %"
                data-info="Percentage of the PLAYER SHARE that is reserved into weekly leaderboard pool.&#10;&#10;This does NOT reduce admin margin directly; it takes a slice from what players would have received in-game.&#10;Used only to pay LB winners.">
                i
              </button>
            </span>
          </label>
          <input id="lbReservePct" type="number" value="10" min="0" max="100" step="1" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>Leaderboard Top N</span>
              <button type="button" class="info-icon" data-title="Leaderboard Top N"
                data-info="How many ranks will receive weekly leaderboard rewards.&#10;&#10;Example: 3 → Only Top 3 players by total winnings will get a share of the LB pool.">
                i
              </button>
            </span>
          </label>
          <input id="lbTopN" type="number" value="3" min="1" max="10" step="1" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>Leaderboard Prize % per Rank</span>
              <button type="button" class="info-icon" data-title="Leaderboard Prize % per Rank"
                data-info="Comma separated percentages that split the leaderboard pool among top N ranks.&#10;Example: 50,30,20 → Rank1=50%, Rank2=30%, Rank3=20%.">
                i
              </button>
            </span>
          </label>
          <input id="lbPrizePercents" type="text" value="50,30,20" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>Game Counts (batches)</span>
              <button type="button" class="info-icon" data-title="Game Counts"
                data-info="Number of games to simulate in each batch.&#10;Example: 100,500,1000,5000&#10;→ 4 batches of increasing volume to see stability at scale.">
                i
              </button>
            </span>
          </label>
          <input id="gameCounts" type="text" value="100,500,1000,5000" />
        </div>

        <div>
          <label>
            <span class="label-row">
              <span>Adaptive RTP / Rescue Mode</span>
              <button type="button" class="info-icon" data-title="Adaptive RTP / Rescue Mode"
                data-info="When ON, system adjusts Admin% and dice behavior based on per-player loss/win streaks.&#10;&#10;Goal: help losing users recover sometimes and cool down over-winning users, without breaking randomness feel.">
                i
              </button>
            </span>
          </label>
          <div>
            <input id="adaptiveRtp" type="checkbox" checked /> <span class="small-text">Enabled</span>
          </div>
        </div>
      </div>

      <div class="button-row">
        <button id="runBtn">▶ Run Simulation</button>
        <button id="resetBtn" class="btn-secondary" type="button">Reset Defaults</button>
        <button id="exportBtn" class="btn-outline" type="button" disabled>⬇ Export Summary CSV</button>
        <span id="status" class="status"></span>
        <span id="progressText" class="progress-text"></span>
      </div>
    </div>

    <!-- SUMMARY -->
    <div class="card">
      <h2>Summary Results</h2>
      <p class="small-text">One row per batch. Net values are combined for all players.</p>
      <div id="resultsContainer">
        <p class="small-text">No results yet.</p>
      </div>
    </div>

    <!-- DETAILS -->
    <div class="card">
      <h2>Per-Game Detail</h2>
      <p class="small-text">Select batch and click Game # to see board and dice paths. (Large runs: load per-batch on
        demand.)</p>
      <div class="button-row" style="margin-top:0;">
        <label class="small-text">Select Batch:</label>
        <select id="batchSelect">
          <option value="">No data yet</option>
        </select>

        <!-- pagination controls for big batches (request slices from worker) -->
        <label class="small-text">Page size:</label>
        <select id="pageSizeSelect">
          <option value="10">10</option>
          <option value="25" selected>25</option>
          <option value="50">50</option>
          <option value="100">100</option>
        </select>
        <button id="prevPageBtn" class="btn-secondary" type="button">◀ Prev</button>
        <button id="nextPageBtn" class="btn-secondary" type="button">Next ▶</button>
        <span id="pageInfo" class="small-text" style="margin-left:8px">Page 0 / 0</span>
      </div>

      <div id="detailContainer" style="margin-top:10px;">
        <p class="small-text">Run a simulation to view details.</p>
      </div>
    </div>

    <!-- CHARTS -->
    <div class="card">
      <h2>Charts</h2>
      <div class="charts-grid">
        <div><canvas id="avgProfitChart" height="200"></canvas></div>
        <div><canvas id="balanceChart" height="200"></canvas></div>
      </div>
    </div>

    <!-- LEADERBOARD -->
    <div class="card">
      <h2>Weekly Leaderboard (Simulated)</h2>
      <div id="leaderboardContainer">
        <p class="small-text">Run simulation to see leaderboard.</p>
      </div>
    </div>

    <!-- ALGORITHM NOTES -->
    <div class="card">
      <h2>Algorithm Notes</h2>
      <p class="small-text">
        <strong>Board:</strong> 100-box Snakes &amp; Ladders board, with fixed snake/ladder positions. Reward boxes are
        only placed on safe tiles (no snake/ladder start or end).
      </p>
      <ul class="small-text">
        <li>~25 reward boxes selected based on hit probability zones (early/mid/late board).</li>
        <li>Each reward box has a weight; base unit = payoutBudget / Σ(weight of reward boxes).</li>
        <li>Box reward = floor(weight × baseUnit), min 1, always integer.</li>
      </ul>
      <p class="small-text">
        <strong>Dynamic RTP:</strong><br />
        • Admin % automatically changes based on worst player recent loss (Base / Medium-Loss / High-Loss).<br />
        • Dice is random by default, but can be biased in two modes:
      </p>
      <ul class="small-text">
        <li><strong>Recovery mode:</strong> help long-losing players land on reward tiles where possible.</li>
        <li><strong>Cooling mode:</strong> gently avoid extra rewards for over-winning players.</li>
      </ul>
      <p class="small-text">
        <strong>Per-Game Cap:</strong><br />
        • 2 players → max ~80% of total payout can go to single player.<br />
        • 3 players → max ~70%.<br />
        • 4 players → max ~60%.<br />
        Remaining rewards go to other players or stay in pool for future games.
      </p>
      <p class="small-text">
        <strong>Leaderboard:</strong> Funded from a % of player share, not from admin profit. Pool is only used to pay
        weekly leaderboard winners, never re-used inside gameplay.
      </p>
    </div>
  </div>

  <!-- Shared tooltip element -->
  <div id="configTooltip" class="tooltip hidden">
    <button class="tooltip-close" type="button" aria-label="Close">✕</button>
    <div class="tooltip-title"></div>
    <div class="tooltip-body"></div>
  </div>

  <script>
    /* ---------- Board (Snakes & Ladders) ---------- */
    const LADDERS = [
      { start: 4, end: 18 },
      { start: 22, end: 42 },
      { start: 35, end: 58 },
      { start: 63, end: 78 },
      { start: 83, end: 96 }
    ];
    const SNAKES = [
      { start: 15, end: 6 },
      { start: 31, end: 14 },
      { start: 38, end: 22 },
      { start: 53, end: 38 },
      { start: 72, end: 40 },
      { start: 93, end: 70 }
    ];

    function createRNG() {
      return { random: () => Math.random() };
    }

    /* ---------- UI wiring ---------- */
    const runBtnEl = document.getElementById('runBtn');
    const resetBtn = document.getElementById('resetBtn');
    const exportBtn = document.getElementById('exportBtn');
    const statusEl = document.getElementById('status');
    const progressTextEl = document.getElementById('progressText');
    const resultsContainer = document.getElementById('resultsContainer');
    const batchSelect = document.getElementById('batchSelect');
    const detailContainer = document.getElementById('detailContainer');
    const leaderboardContainer = document.getElementById('leaderboardContainer');
    const pageSizeSelect = document.getElementById('pageSizeSelect');
    const prevPageBtn = document.getElementById('prevPageBtn');
    const nextPageBtn = document.getElementById('nextPageBtn');
    const pageInfo = document.getElementById('pageInfo');

    let simWorker = null;
    let lastResultSummaries = null; // summaries from worker
    let batchesMeta = null;         // metadata about batches (gamesCount)
    // cache for fetched batches on main thread: { [batchIndex]: { games: [...], fetchedRange: {start,count} } }
    let batchCache = {};
    let currentBatchIndex = null;
    let currentPage = 0;

    let lastConfig = null;
    let avgProfitChart = null;
    let balanceChart = null;

    /* ---------- Helper: parse config ---------- */
    function parseConfigFromUI() {
      const val = id => Number(document.getElementById(id).value);
      const entryFee = val('entryFee');
      const numPlayers = val('numPlayers');
      const baseAdminPct = val('baseAdminPct');
      const midAdminPct = val('midAdminPct');
      const highAdminPct = val('highAdminPct');
      const midLossMultiple = val('midLossMultiple');
      const highLossMultiple = val('highLossMultiple');
      const lossStreakTrigger = val('lossStreakTrigger');
      const winStreakTrigger = val('winStreakTrigger');
      const lossGameMultiple = val('lossGameMultiple');
      const bigWinMultiple = val('bigWinMultiple');
      const lbReservePct = val('lbReservePct');
      const lbTopN = val('lbTopN');
      const lbPrizeStr = document.getElementById('lbPrizePercents').value;
      const gameCountsStr = document.getElementById('gameCounts').value;
      const adaptiveRtp = document.getElementById('adaptiveRtp').checked;

      const gameCounts = gameCountsStr.split(',')
        .map(s => Number(s.trim()))
        .filter(n => !isNaN(n) && n > 0);

      if (!entryFee || entryFee <= 0) throw new Error("Entry fee must be > 0");
      if (numPlayers < 2 || numPlayers > 4) throw new Error("Players per game must be 2–4");
      if (!gameCounts.length) throw new Error("Game counts missing");

      if (highLossMultiple < midLossMultiple) throw new Error("High-Loss threshold ≥ Medium-Loss required");

      const lbPrizePercents = lbPrizeStr.split(',')
        .map(s => Number(s.trim()))
        .filter(n => !isNaN(n) && n >= 0);
      if (!lbPrizePercents.length) throw new Error("LB prize % invalid");

      return {
        entryFee, numPlayers, adaptiveRtp,
        baseAdminPct, midAdminPct, highAdminPct,
        midLossMultiple, highLossMultiple,
        lossStreakTrigger, winStreakTrigger,
        lossGameMultiple, bigWinMultiple,
        lbReservePct, lbTopN, lbPrizePercents,
        gameCounts
      };
    }

    /* ---------- Chart & UI render helpers ---------- */
    function renderSummaryTable(summaries) {
      if (!summaries || !summaries.length) {
        resultsContainer.innerHTML = `<p class="small-text">No data.</p>`;
        exportBtn.disabled = true;
        return;
      }
      let html = `
      <table>
        <thead>
          <tr>
            <th>Games</th>
            <th>Total Admin Net</th>
            <th>Total Player Net</th>
            <th>Avg Admin/Game</th>
            <th>Avg Player/Game</th>
            <th>Pool After</th>
            <th>House After</th>
            <th>LB Pool After</th>
          </tr>
        </thead><tbody>`;
      summaries.forEach(s => {
        html += `<tr>
          <td>${s.games}</td>
          <td>${s.totalAdminNet.toFixed(2)}</td>
          <td>${s.totalPlayerNet.toFixed(2)}</td>
          <td>${s.avgAdminPerGame.toFixed(2)}</td>
          <td>${s.avgPlayerPerGame.toFixed(2)}</td>
          <td>${s.poolAfter.toFixed(2)}</td>
          <td>${s.houseAfter.toFixed(2)}</td>
          <td>${(s.leaderboardPoolAfter || 0).toFixed(2)}</td>
        </tr>`;
      });
      html += `</tbody></table>`;
      resultsContainer.innerHTML = html;
      exportBtn.disabled = false;
    }

    function updateCharts(summaries) {
      if (!summaries || !summaries.length) return;
      const labels = summaries.map(s => s.games.toString());
      const avgAdmin = summaries.map(s => s.avgAdminPerGame);
      const avgPlayer = summaries.map(s => s.avgPlayerPerGame);
      const poolAfter = summaries.map(s => s.poolAfter);
      const houseAfter = summaries.map(s => s.houseAfter);

      const avgCtx = document.getElementById('avgProfitChart').getContext('2d');
      const balCtx = document.getElementById('balanceChart').getContext('2d');
      if (avgProfitChart) avgProfitChart.destroy();
      if (balanceChart) balanceChart.destroy();

      avgProfitChart = new Chart(avgCtx, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            { label: 'Avg Admin/Game', data: avgAdmin },
            { label: 'Avg Player/Game', data: avgPlayer }
          ]
        },
        options: {
          responsive: true,
          plugins: { legend: { labels: { color: '#e5e7eb' } } },
          scales: { x: { ticks: { color: '#e5e7eb' } }, y: { ticks: { color: '#e5e7eb' } } }
        }
      });

      balanceChart = new Chart(balCtx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label: 'Pool After', data: poolAfter },
            { label: 'House After', data: houseAfter }
          ]
        },
        options: {
          responsive: true,
          plugins: { legend: { labels: { color: '#e5e7eb' } } },
          scales: { x: { ticks: { color: '#e5e7eb' } }, y: { ticks: { color: '#e5e7eb' } } }
        }
      });
    }

    function populateBatchSelect(summaries) {
      batchSelect.innerHTML = '';
      if (!summaries || !summaries.length) {
        batchSelect.innerHTML = '<option value="">No data yet</option>';
        return;
      }
      summaries.forEach((s, idx) => {
        const o = document.createElement('option');
        o.value = String(idx); o.textContent = `${s.games} games`;
        batchSelect.appendChild(o);
      });
      // reset page info
      currentBatchIndex = null;
      currentPage = 0;
      pageInfo.textContent = 'Page 0 / 0';
    }

    /* ---------- Requesting batch/game slices from worker ---------- */
    function requestBatchFromWorker(batchIndex, start = 0, count = 100) {
      return new Promise((resolve, reject) => {
        if (!simWorker) return reject(new Error('No worker available'));
        const id = 'getBatch_' + Date.now() + '_' + Math.random();
        function onMsg(ev) {
          const data = ev.data;
          if (!data || data._reqId !== id) return;
          simWorker.removeEventListener('message', onMsg);
          if (data.status === 'ok' && data.type === 'batchSlice') {
            resolve(data.payload);
          } else {
            reject(new Error(data.message || 'Worker error'));
          }
        }
        simWorker.addEventListener('message', onMsg);
        simWorker.postMessage({ type: 'getBatch', batchIndex, start, count, _reqId: id });
      });
    }

    /* ---------- Render batch list (on-demand) ---------- */
    async function renderBatchDetail(index) {
      if (index == null || index === '' || !lastResultSummaries) {
        detailContainer.innerHTML = `<p class="small-text">Select a batch.</p>`; return;
      }
      const bi = Number(index);
      currentBatchIndex = bi;
      // page size & compute page info
      const pageSize = Number(pageSizeSelect.value) || 25;
      const totalGames = batchesMeta && batchesMeta[bi] ? batchesMeta[bi].gamesCount : (lastResultSummaries[bi] ? lastResultSummaries[bi].games : 0);
      const totalPages = Math.max(1, Math.ceil(totalGames / pageSize));
      if (currentPage >= totalPages) currentPage = totalPages - 1;
      if (currentPage < 0) currentPage = 0;
      const start = currentPage * pageSize;
      const count = Math.min(pageSize, totalGames - start);

      pageInfo.textContent = `Page ${currentPage + 1} / ${totalPages}`;

      // if we have this batch cached AND it contains the requested range, use cache
      const cache = batchCache[bi];
      if (cache && cache.fetchedRange && cache.fetchedRange.start <= start && (cache.fetchedRange.start + cache.fetchedRange.count) >= (start + count)) {
        // slice from cache
        const sliceStart = start - cache.fetchedRange.start;
        const slice = cache.games.slice(sliceStart, sliceStart + count);
        renderBatchTableFromGames(bi, slice, totalGames, start, count);
        return;
      }

      // otherwise request from worker
      detailContainer.innerHTML = `<p class="small-text">Loading batch ${bi} (games ${start + 1} - ${start + count}) …</p>`;
      try {
        const payload = await requestBatchFromWorker(bi, start, count);
        // payload: { games: [...], batchIndex, start, count, totalGames }
        // cache this fetched slice (we'll store as the fetchedRange and games)
        batchCache[bi] = {
          games: payload.games.slice(), // store array
          fetchedRange: { start: payload.start, count: payload.games.length },
          totalGames: payload.totalGames
        };
        renderBatchTableFromGames(bi, payload.games, payload.totalGames, payload.start, payload.games.length);
      } catch (err) {
        detailContainer.innerHTML = `<p class="error">Batch load error: ${err.message}</p>`;
      }
    }

    function renderBatchTableFromGames(batchIndex, games, totalGames, start, count) {
      const N = lastConfig ? lastConfig.numPlayers : 0;
      const fmt = (r, i) => (i < N && r && typeof r[i] === 'number') ? r[i].toFixed(2) : '-';
      let html = `
      <div class="small-text">Showing games ${start + 1} - ${start + count} of ${totalGames}. Click Game # to load its full details.</div>
      <div style="max-height:360px;overflow:auto;">
      <table><thead>
        <tr>
          <th>Game #</th>
          <th>Total Entry</th>
          <th>Total Payout</th>
          <th>P1 Reward</th><th>P2 Reward</th><th>P3 Reward</th><th>P4 Reward</th>
          <th>Admin %</th><th>Admin Net</th>
          <th>LB Reserve</th><th>Pool After</th><th>House After</th><th>Scale</th>
        </tr></thead><tbody>`;
      games.forEach((g, idx) => {
        const r = g.perPlayerRewards || [];
        html += `<tr>
          <td><button class="game-link-btn" data-game-index="${start + idx}">${g.gameNo}</button></td>
          <td>${g.totalEntry.toFixed(2)}</td>
          <td>${g.totalPayout.toFixed(2)}</td>
          <td>${fmt(r, 0)}</td><td>${fmt(r, 1)}</td><td>${fmt(r, 2)}</td><td>${fmt(r, 3)}</td>
          <td>${(g.adminPctUsed || 0).toFixed(1)}</td>
          <td>${g.adminNet.toFixed(2)}</td>
          <td>${(g.lbContribution || 0).toFixed(2)}</td>
          <td>${g.poolAfter.toFixed(2)}</td>
          <td>${g.houseAfter.toFixed(2)}</td>
          <td>${g.globalScale.toFixed(3)}</td>
        </tr>`;
      });
      html += `</tbody></table></div>
        <div id="gameVisual" class="small-text" style="margin-top:10px;">
          Click a Game # to see board and dice paths.
        </div>`;
      detailContainer.innerHTML = html;
    }

    /* ---------- Render single game's visual: request full game details if necessary ---------- */
    async function renderGameVisualByGlobalIndex(gameGlobalIndex) {
      // determine batch index for this global index
      // We need mapping: each batch has gamesCount (e.g., 100,500...). Batches are sequential.
      if (!batchesMeta || !lastResultSummaries) return;
      // find batch containing gameGlobalIndex (1-based)
      let running = 0;
      let batchIdx = -1;
      let localIndex = -1;
      for (let i = 0; i < batchesMeta.length; i++) {
        const cnt = batchesMeta[i].gamesCount;
        if (gameGlobalIndex >= running + 1 && gameGlobalIndex <= running + cnt) {
          batchIdx = i;
          localIndex = gameGlobalIndex - running - 1; // 0-based index inside batch
          break;
        }
        running += cnt;
      }
      if (batchIdx < 0) {
        detailContainer.innerHTML = `<p class="small-text">Game not found.</p>`;
        return;
      }

      // ensure that batch is current batch in UI for pagination convenience
      // compute page size & page number for this local index
      const pageSize = Number(pageSizeSelect.value) || 25;
      const pageNum = Math.floor(localIndex / pageSize);
      currentBatchIndex = batchIdx;
      currentPage = pageNum;

      // request single game from worker
      try {
        const payload = await requestBatchFromWorker(batchIdx, localIndex, 1); // ask for that single game
        if (!payload || !payload.games || !payload.games.length) {
          detailContainer.innerHTML = `<p class="error">Could not fetch game details from worker.</p>`;
          return;
        }
        // also update batch cache for this batch by invalidating (so next batch list load will fetch)
        batchCache[batchIdx] = {
          games: payload.games.slice(), // store the single game
          fetchedRange: { start: payload.start, count: payload.games.length },
          totalGames: payload.totalGames
        };
        // Render batch detail page using page that includes this game (so table shows around it)
        await renderBatchDetail(String(batchIdx));
        // then show the visual for the specific game (global index mapped to batch-local)
        // find its button and click programmatically
        const btns = detailContainer.querySelectorAll('.game-link-btn');
        for (let b of btns) {
          if (Number(b.dataset.gameIndex) === localIndex) {
            b.click();
            return;
          }
        }
        // if not found on page (because page size smaller), request and render the game's visual directly:
        renderGameVisualFromObject(payload.games[0]);
      } catch (err) {
        detailContainer.innerHTML = `<p class="error">Failed to load game: ${err.message}</p>`;
      }
    }

    function renderGameVisualFromObject(game) {
      if (!game) return;
      const events = game.events || [];
      const eventMap = {};
      events.forEach(ev => { eventMap[ev.boxIndex] = ev; });

      let perPlayerSummary = '';
      if (lastConfig && game.perPlayerRewards) {
        const N = lastConfig.numPlayers;
        const labels = [];
        for (let i = 0; i < N; i++) {
          const val = game.perPlayerRewards[i] || 0;
          const net = game.perPlayerNet ? game.perPlayerNet[i] || 0 : 0;
          labels.push('P' + (i + 1) + ': reward ' + val.toFixed(2) + ', net ' + net.toFixed(2));
        }
        perPlayerSummary = ' | ' + labels.join(' | ');
      }

      let html = `
        <div class="game-visual-header">
          <strong>Game #${game.gameNo}</strong> — Entry: ${game.totalEntry.toFixed(2)},
          Payout: ${game.totalPayout.toFixed(2)}, Admin Net: ${game.adminNet.toFixed(2)},
          Player Net: ${game.playerNet.toFixed(2)}${perPlayerSummary}
          <br/>Admin %: ${(game.adminPctUsed || 0).toFixed(1)}%, Scale: ${game.globalScale.toFixed(3)},
          Pool after: ${game.poolAfter.toFixed(2)}, LB Reserve: ${(game.lbContribution || 0).toFixed(2)}
        </div>
        <div class="board-grid">`;

      for (let box = 1; box <= 100; box++) {
        const ev = eventMap[box];
        let classes = 'board-cell';
        let tag = ''; let arrow = '';

        const liStart = LADDERS.findIndex(l => l.start === box);
        const liEnd = LADDERS.findIndex(l => l.end === box);
        const siStart = SNAKES.findIndex(s => s.start === box);
        const siEnd = SNAKES.findIndex(s => s.end === box);

        if (liStart >= 0) { classes += ' ladder-start'; tag = 'L' + (liStart + 1) + '-Start'; arrow = '↑'; }
        else if (liEnd >= 0) { classes += ' ladder-end'; tag = 'L' + (liEnd + 1) + '-End'; arrow = '▲'; }
        if (siStart >= 0) { classes += ' snake-start'; tag = 'S' + (siStart + 1) + '-Start'; arrow = '↓'; }
        else if (siEnd >= 0) { classes += ' snake-end'; tag = 'S' + (siEnd + 1) + '-End'; arrow = '▼'; }

        if (ev) classes += ' hit';

        html += '<div class="' + classes + '">'
          + box
          + (arrow ? ('<span class="board-arrow">' + arrow + '</span>') : '')
          + (tag ? ('<span class="board-tag">' + tag + '</span>') : '')
          + (ev ? ('<span>+' + ev.rewardGiven + '</span>') : '')
          + '</div>';
      }
      html += '</div>';

      html += '<div class="timeline">';
      if (!events.length) {
        html += '<div class="timeline-item">No rewards in this game.</div>';
      } else {
        events.forEach((ev, idx) => {
          const pid = (typeof ev.playerIndex === 'number') ? ('P' + (ev.playerIndex + 1) + ': ') : '';
          html += '<div class="timeline-item">'
            + 'Step ' + (idx + 1) + ': ' + pid + 'Box ' + ev.boxIndex + ' → +' + ev.rewardGiven
            + ' (Pool: ' + Math.round(ev.poolBefore) + ' → ' + Math.round(ev.poolAfter) + ')'
            + '</div>';
        });
      }
      html += '</div>';

      // dice paths
      html += '<div class="dice-path">';
      if (!lastConfig || !game.diceSteps) {
        html += '<div class="timeline-item">No dice data.</div>';
      } else {
        const N = lastConfig.numPlayers;
        for (let p = 0; p < N; p++) {
          const steps = game.diceSteps[p] || [];
          if (!steps.length) continue;
          let totalReward = 0;
          html += '<div class="dice-player-block">'
            + '<div class="dice-player-title">Dice Path for Player P' + (p + 1) + '</div>'
            + '<table class="dice-table"><thead><tr>'
            + '<th>Turn</th><th>Random Dice</th><th>Final Dice</th>'
            + '<th>From</th><th>To</th><th>Reward</th><th>Note</th>'
            + '</tr></thead><tbody>';
          steps.forEach(s => {
            totalReward += s.reward;
            html += '<tr>'
              + '<td>' + s.turn + '</td><td>' + s.randomDice + '</td><td>' + s.finalDice + '</td>'
              + '<td>' + s.from + '</td><td>' + s.to + '</td>'
              + '<td>' + Math.round(s.reward) + '</td>'
              + '<td style="text-align:left;">' + s.note + '</td>'
              + '</tr>';
          });
          html += '<tr class="dice-total-row">'
            + '<td colspan="5" style="text-align:right;">Total Reward</td>'
            + '<td>' + Math.round(totalReward) + '</td><td></td>'
            + '</tr>';
          html += '</tbody></table></div>';
        }
      }
      html += '</div>';

      const gv = document.getElementById('gameVisual');
      if (gv) gv.innerHTML = html;
    }

    /* ---------- Export summary CSV ---------- */
    function exportSummaryCSV(summaries) {
      if (!summaries || !summaries.length) return;
      const header = [
        'Games_Simulated', 'Total_Admin_Net', 'Total_Player_Net',
        'Avg_Admin_per_Game', 'Avg_Player_per_Game',
        'PoolAfter', 'HouseAfter', 'LBPoolAfter'
      ];
      const rows = summaries.map(s => [
        s.games,
        s.totalAdminNet.toFixed(2),
        s.totalPlayerNet.toFixed(2),
        s.avgAdminPerGame.toFixed(2),
        s.avgPlayerPerGame.toFixed(2),
        s.poolAfter.toFixed(2),
        s.houseAfter.toFixed(2),
        (s.leaderboardPoolAfter || 0).toFixed(2)
      ]);
      let csv = header.join(',') + '\n';
      rows.forEach(r => { csv += r.join(',') + '\n'; });
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'snl_economy_summary.csv'; a.click();
      URL.revokeObjectURL(url);
    }

    /* ---------- Worker creation & protocol ---------- */
    function createSimWorker() {
      // terminate old worker if exists and clear its memory
      if (simWorker) {
        try { simWorker.terminate(); } catch (e) { }
        simWorker = null;
      }

      // worker code string
      const workerCode = `
        // Worker code — runs heavy simulation and keeps detailed batches in worker memory.
        const LADDERS = ${JSON.stringify(LADDERS)};
        const SNAKES  = ${JSON.stringify(SNAKES)};

        function createRNG() { return { random: () => Math.random() }; }

        // internal storage inside worker
        let workerBatches = []; // each batch: { gamesCount, games: [ ... ] }
        let workerSummaries = [];
        let workerLeaderboard = null;

        // helper: runs the simulation (same algorithm) but posts progress periodically
        onmessage = function(ev) {
          const msg = ev.data || {};
          if (msg && msg.type === 'run') {
            try {
              workerBatches = [];
              workerSummaries = [];
              workerLeaderboard = null;
              runSimulationWorker(msg.config, msg._reqId);
            } catch(err) {
              postMessage({ status: 'error', message: err.message || String(err), _reqId: msg._reqId });
            }
            return;
          }
          if (msg && msg.type === 'getBatch') {
            // reply with requested batch slice
            const batchIndex = msg.batchIndex;
            const start = msg.start || 0;
            const count = msg.count || 100;
            const _reqId = msg._reqId;
            if (typeof batchIndex !== 'number' || batchIndex < 0 || batchIndex >= workerBatches.length) {
              postMessage({ status:'error', message:'Invalid batchIndex', _reqId });
              return;
            }
            const batch = workerBatches[batchIndex];
            const totalGames = batch.gamesCount;
            // ensure start within bounds
            const s = Math.max(0, Math.min(start, totalGames - 1));
            const c = Math.max(0, Math.min(count, totalGames - s));
            // slice requested games (may be heavy if c large)
            const slice = batch.games.slice(s, s + c);
            postMessage({ status:'ok', type:'batchSlice', payload:{ batchIndex, start:s, count:c, games: slice, totalGames }, _reqId });
            return;
          }
          if (msg && msg.type === 'terminate') {
            // cleanup memory
            workerBatches = []; workerSummaries = []; workerLeaderboard = null;
            postMessage({ status:'ok', type:'terminated', _reqId: msg._reqId });
            // worker will not self-close; main thread should terminate
            return;
          }
        };

        function runSimulationWorker(config, reqId) {
          const ENTRY_FEE   = config.entryFee;
          const N_PLAYERS   = config.numPlayers;
          const adaptiveRtp = config.adaptiveRtp;
          const baseAdminPct = config.baseAdminPct;
          const midAdminPct  = config.midAdminPct;
          const highAdminPct = config.highAdminPct;
          const midLossMultiple  = config.midLossMultiple;
          const highLossMultiple = config.highLossMultiple;
          const lossStreakTrigger = config.lossStreakTrigger;
          const winStreakTrigger  = config.winStreakTrigger;
          const lossGameMultiple  = config.lossGameMultiple;
          const bigWinMultiple    = config.bigWinMultiple;
          const lbReservePct = config.lbReservePct;
          const gameCounts   = config.gameCounts;
          const rng          = createRNG();

          const ladderStarts = new Set(LADDERS.map(l => l.start));
          const snakeStarts  = new Set(SNAKES.map(s => s.start));

          const weights = new Array(101).fill(0);
          const hitProb = new Array(101).fill(0);

          for (let i = 1; i <= 100; i++) {
            if (i >= 1 && i <= 20) {
              weights[i] = 1; hitProb[i] = 0.7;
            } else if (i >= 21 && i <= 60) {
              weights[i] = 2; hitProb[i] = 0.5;
            } else if (i >= 61 && i <= 90) {
              weights[i] = 3; hitProb[i] = 0.3;
            } else if (i >= 91 && i <= 99) {
              weights[i] = 4; hitProb[i] = 0.15;
            } else if (i === 100) {
              weights[i] = 8; hitProb[i] = 0.05;
            }
          }

          const candidates = [];
          for (let i = 1; i <= 100; i++) {
            if (hitProb[i] > 0 && !ladderStarts.has(i) && !snakeStarts.has(i)) {
              candidates.push(i);
            }
          }
          const rewardCells = new Set();
          const TARGET_REWARD_BOXES = 25;
          if (candidates.length <= TARGET_REWARD_BOXES) {
            candidates.forEach(i => rewardCells.add(i));
          } else {
            const step = candidates.length / TARGET_REWARD_BOXES;
            for (let k = 0; k < TARGET_REWARD_BOXES; k++) {
              rewardCells.add(candidates[Math.floor(k * step)]);
            }
          }
          for (let i = 1; i <= 100; i++) {
            if (!rewardCells.has(i)) hitProb[i] = 0;
          }

          let activeWeightSum = 0;
          for (let i = 1; i <= 100; i++) {
            if (hitProb[i] > 0) activeWeightSum += weights[i];
          }

          const lifetimeNet = new Array(N_PLAYERS).fill(0);
          const LOSS_WINDOW = 20;
          const recentNets = Array.from({ length: N_PLAYERS }, () => []);

          const lossStreak = new Array(N_PLAYERS).fill(0);
          const winStreak  = new Array(N_PLAYERS).fill(0);

          const LOSS_GAME_NET_THRESHOLD = -lossGameMultiple * ENTRY_FEE;
          const BIG_WIN_NET_THRESHOLD   =  bigWinMultiple * ENTRY_FEE;

          const leaderboardScores = new Array(N_PLAYERS).fill(0);
          let leaderboardPool = 0;

          function applySnakesAndLadders(pos) {
            let dest = pos;
            const ladder = LADDERS.find(l => l.start === dest);
            if (ladder) return { dest: ladder.end, type: 'ladder', idx: LADDERS.indexOf(ladder) };
            const snake = SNAKES.find(s => s.start === dest);
            if (snake) return { dest: snake.end, type: 'snake', idx: SNAKES.indexOf(snake) };
            return { dest, type: null, idx: -1 };
          }

          function simulateBatch(numGames, poolStart, houseStart, progressBase, progressRange) {
            let poolBalance  = poolStart;
            let houseBalance = houseStart;

            let totalAdminNet  = 0;
            let totalPlayerNet = 0;
            const gameRows = [];
            const minReward = 1;
            const safetyFactor = 1.5;

            const CAP_FRACTION =
              (N_PLAYERS <= 2) ? 0.8 :
              (N_PLAYERS === 3) ? 0.7 : 0.6;

            for (let g = 1; g <= numGames; g++) {
              const positions = new Array(N_PLAYERS).fill(0);

              let adminPctGame = baseAdminPct;
              if (adaptiveRtp) {
                let worstLossAbs = 0;
                for (let p = 0; p < N_PLAYERS; p++) {
                  const arr = recentNets[p];
                  let sum = 0;
                  for (let k = 0; k < arr.length; k++) sum += arr[k];
                  const lossAbs = Math.max(0, -sum);
                  worstLossAbs = Math.max(worstLossAbs, lossAbs);
                }
                if (worstLossAbs >= highLossMultiple * ENTRY_FEE)      adminPctGame = highAdminPct;
                else if (worstLossAbs >= midLossMultiple * ENTRY_FEE)  adminPctGame = midAdminPct;
              }

              const playerSharePct = 1 - adminPctGame / 100;
              const totalEntry  = ENTRY_FEE * N_PLAYERS;
              const playerShare = totalEntry * playerSharePct;

              const lbContributionFromPlayers = lbReservePct > 0
                ? playerShare * (lbReservePct / 100)
                : 0;

              const payoutBudget = playerShare - lbContributionFromPlayers;
              const adminBudget  = totalEntry - playerShare;

              let lbContribution = lbContributionFromPlayers;

              poolBalance     += payoutBudget;
              leaderboardPool += lbContributionFromPlayers;
              houseBalance    += adminBudget;

              const baseUnit = activeWeightSum > 0 ? (payoutBudget / activeWeightSum) : 0;

              const boxReward = new Array(101).fill(0);
              for (let i = 1; i <= 100; i++) {
                if (hitProb[i] > 0) {
                  boxReward[i] = baseUnit * weights[i] / hitProb[i];
                }
              }
              for (let i = 1; i <= 100; i++) {
                if (boxReward[i] > 0) {
                  boxReward[i] = Math.max(minReward, Math.floor(boxReward[i])); // integer
                }
              }
              const remainingReward = boxReward.slice();

              const maxAllowablePayout = safetyFactor > 0 ? (poolBalance / safetyFactor) : poolBalance;
              let globalScale;
              if (maxAllowablePayout >= payoutBudget)      globalScale = 1.0;
              else if (maxAllowablePayout <= 0)           globalScale = 0.1;
              else                                        globalScale = maxAllowablePayout / payoutBudget;

              let totalPayout = 0;
              const events = [];
              const perPlayerRewards = new Array(N_PLAYERS).fill(0);
              const diceStepsByPlayer = Array.from({ length: N_PLAYERS }, () => []);
              let turnCounter = 1;
              let gameOver = false;

              function isLosingPlayer(pIdx) {
                return lossStreak[pIdx] >= lossStreakTrigger;
              }
              function isWinningTooMuch(pIdx) {
                const lifetime = lifetimeNet[pIdx];
                let recentNet = 0;
                const arr = recentNets[pIdx] || [];
                for (let i = 0; i < arr.length; i++) recentNet += arr[i];
                const hotByLifetime = lifetime > 0;
                const hotByRecent   = recentNet >= BIG_WIN_NET_THRESHOLD;
                return (winStreak[pIdx] >= winStreakTrigger) && (hotByLifetime || hotByRecent);
              }
              function simulateDestFrom(pos, d) {
                let tmpPos = pos + d;
                if (tmpPos > 100) tmpPos = 100;
                const snl = applySnakesAndLadders(tmpPos);
                return snl.dest;
              }

              while (!gameOver) {
                for (let p = 0; p < N_PLAYERS; p++) {
                  if (gameOver) break;
                  let fromPos = positions[p];
                  if (fromPos >= 100) continue;

                  const randomDice = Math.floor(rng.random() * 6) + 1;
                  let finalDice = randomDice;
                  let diceReason = '';

                  const losing         = isLosingPlayer(p);
                  const winningTooMuch = isWinningTooMuch(p);
                  const randomDest     = simulateDestFrom(fromPos, randomDice);

                  if (adaptiveRtp && losing) {
                    let chosen = null; let chosenDest = randomDest;
                    for (let d = 1; d <= 6; d++) {
                      const dest = simulateDestFrom(fromPos, d);
                      if (rewardCells.has(dest) && remainingReward[dest] > 0) {
                        chosen = d; chosenDest = dest; break;
                      }
                    }
                    if (chosen !== null && chosen !== randomDice) {
                      finalDice = chosen;
                      diceReason = 'Random dice was ' + randomDice + ', changed to ' + finalDice + ' to help recovery towards reward box ' + chosenDest + '.';
                    } else {
                      diceReason = 'Random dice ' + randomDice + ' used as-is.';
                    }
                  } else if (adaptiveRtp && winningTooMuch) {
                    const destIsReward = rewardCells.has(randomDest) && remainingReward[randomDest] > 0;
                    if (destIsReward) {
                      let alt = null; let altDest = randomDest;
                      for (let d = 1; d <= 6; d++) {
                        const dest = simulateDestFrom(fromPos, d);
                        if (!rewardCells.has(dest) || remainingReward[dest] <= 0) {
                          alt = d; altDest = dest; break;
                        }
                      }
                      if (alt !== null && alt !== randomDice) {
                        finalDice = alt;
                        diceReason = 'Random dice was ' + randomDice + ' (reward), changed to ' + finalDice + ' to limit extra win (landed on ' + altDest + ').';
                      } else {
                        diceReason = 'Random dice ' + randomDice + ' used as-is (no safe alternative).';
                      }
                    } else {
                      diceReason = 'Random dice ' + randomDice + ' used as-is (player already in profit, but no instant reward).';
                    }
                  } else {
                    diceReason = 'Random dice ' + randomDice + ' used as-is.';
                  }

                  let stepPos = fromPos + finalDice;
                  if (stepPos > 100) stepPos = 100;
                  let snlInfo = applySnakesAndLadders(stepPos);
                  let toPos = snlInfo.dest;

                  let snlNote = '';
                  if (snlInfo.type === 'ladder') snlNote = ' Climbed Ladder ' + (snlInfo.idx + 1) + ': ' + stepPos + ' → ' + toPos + '.';
                  else if (snlInfo.type === 'snake') snlNote = ' Bitten by Snake ' + (snlInfo.idx + 1) + ': ' + stepPos + ' → ' + toPos + '.';

                  positions[p] = toPos;

                  let reward = 0;
                  if (rewardCells.has(toPos) && remainingReward[toPos] > 0) {
                    let baseRemaining = remainingReward[toPos];
                    let boxPay = 0;
                    if (baseRemaining > 0) {
                      boxPay = Math.floor(baseRemaining * globalScale);
                      if (boxPay < minReward) boxPay = minReward;
                    }
                    if (boxPay > poolBalance) boxPay = Math.floor(poolBalance);
                    if (boxPay > 0) {
                      const projectedTotal = totalPayout + boxPay;
                      const playerCap = CAP_FRACTION * projectedTotal;
                      let capacity = playerCap - perPlayerRewards[p];
                      if (capacity < 0) capacity = 0;
                      let give = Math.min(boxPay, capacity, poolBalance);
                      give = Math.floor(give);
                      if (give > 0) {
                        poolBalance -= give;
                        perPlayerRewards[p] += give;
                        leaderboardScores[p] += give;
                        totalPayout += give;
                        remainingReward[toPos] -= give;
                        if (remainingReward[toPos] < 0) remainingReward[toPos] = 0;

                        reward += give;
                        events.push({
                          boxIndex: toPos,
                          rewardGiven: give,
                          poolBefore: poolBalance + give,
                          poolAfter: poolBalance,
                          playerIndex: p
                        });
                      }
                    }
                  }

                  const noteFull = diceReason + snlNote;
                  diceStepsByPlayer[p].push({
                    turn: turnCounter++,
                    randomDice: randomDice,
                    finalDice: finalDice,
                    from: fromPos,
                    to: toPos,
                    reward: reward,
                    note: noteFull
                  });

                  if (toPos >= 100) { gameOver = true; break; }
                }
              }

              const perPlayerNet = perPlayerRewards.map(function(r){ return r - ENTRY_FEE; });
              const playerNet = perPlayerNet.reduce(function(a,b){ return a + b; }, 0);

              // update streaks
              for (let p = 0; p < N_PLAYERS; p++) {
                const net = perPlayerNet[p];
                if (net <= LOSS_GAME_NET_THRESHOLD) {
                  lossStreak[p] += 1; winStreak[p] = 0;
                } else if (net >= BIG_WIN_NET_THRESHOLD) {
                  winStreak[p] += 1;  lossStreak[p] = 0;
                } else {
                  lossStreak[p] = 0;  winStreak[p] = 0;
                }
              }

              let adminNet = totalEntry - totalPayout;
              totalPlayerNet += playerNet;
              totalAdminNet  += adminNet;

              for (let p = 0; p < N_PLAYERS; p++) {
                lifetimeNet[p] += perPlayerNet[p];
                const arr = recentNets[p];
                arr.push(perPlayerNet[p]);
                if (arr.length > LOSS_WINDOW) arr.shift();
              }

              gameRows.push({
                gameNo: g,
                totalEntry: totalEntry,
                payoutBudget: payoutBudget,
                adminBudget: adminBudget,
                totalPayout: totalPayout,
                perPlayerRewards: perPlayerRewards,
                perPlayerNet: perPlayerNet,
                playerNet: playerNet,
                adminNet: adminNet,
                lbContribution: lbContribution,
                adminPctUsed: adminPctGame,
                poolAfter: poolBalance,
                houseAfter: houseBalance,
                globalScale: globalScale,
                events: events,
                diceSteps: diceStepsByPlayer
              });

              // periodically post progress (map g within this batch to overall progress)
              if (g % 100 === 0) {
                const progress = progressBase + (progressRange * (g / numGames));
                postMessage({ status:'progress', progress: Math.min(100, Math.round(progress)), _reqId: reqId });
              }
            }

            return {
              poolBalance: poolBalance,
              houseBalance: houseBalance,
              totalAdminNet: totalAdminNet,
              totalPlayerNet: totalPlayerNet,
              avgAdminPerGame: totalAdminNet / numGames,
              avgPlayerPerGame: totalPlayerNet / numGames,
              games: gameRows
            };
          }

          // run batches in sequence; keep all batch-game details in workerBatches
          let pool = 0, house = 0;
          const summaries = [];
          const batches = [];
          let totalBatches = gameCounts.length;
          for (let bi = 0; bi < gameCounts.length; bi++) {
            const c = gameCounts[bi];
            // progress mapping: start 0..100 across all batches
            const base = (bi / totalBatches) * 100;
            const range = (1 / totalBatches) * 100;
            // simulate batch
            const res = simulateBatch(c, pool, house, base, range);
            pool = res.poolBalance;
            house = res.houseBalance;
            summaries.push({
              games: c,
              totalAdminNet: res.totalAdminNet,
              totalPlayerNet: res.totalPlayerNet,
              avgAdminPerGame: res.avgAdminPerGame,
              avgPlayerPerGame: res.avgPlayerPerGame,
              poolAfter: pool,
              houseAfter: house,
              leaderboardPoolAfter: leaderboardPool
            });
            // store the whole batch (this keeps full details in worker)
            workerBatches.push({ gamesCount: c, games: res.games });
            batches.push({ gamesCount: c, games: [] }); // lightweight placeholder for main thread
            // notify partial completion of batch to main thread
            postMessage({ status:'partial', batchIndex: bi, summary: summaries[summaries.length - 1], _reqId: reqId });
          }

          workerSummaries = summaries;
          workerLeaderboard = { pool: leaderboardPool, scores: leaderboardScores };
          // final: tell main thread we're done but DO NOT send full batches to main (they remain in worker)
          postMessage({ status:'done', summaries: workerSummaries, batchesMeta: workerBatches.map(b=>({ gamesCount: b.gamesCount })), leaderboard: workerLeaderboard, _reqId: reqId });
        }
      `;

      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);
      simWorker = new Worker(url);
      URL.revokeObjectURL(url);

      // wire up worker progress messages for UI
      simWorker.addEventListener('message', (ev) => {
        const data = ev.data || {};
        if (data.status === 'progress') {
          progressTextEl.textContent = 'Progress: ' + (data.progress || 0) + '%';
        } else if (data.status === 'partial') {
          // partial batch finished
          progressTextEl.textContent = 'Completed batch ' + (data.batchIndex + 1);
        } else if (data.status === 'done') {
          progressTextEl.textContent = '100%';
        }
      });

      return simWorker;
    }

    /* ---------- Run button handler ---------- */
    runBtnEl.addEventListener('click', async () => {
      statusEl.textContent = ''; resultsContainer.innerHTML = '';
      detailContainer.innerHTML = '<p class="small-text">Running...</p>';
      leaderboardContainer.innerHTML = '<p class="small-text">Running...</p>';
      progressTextEl.textContent = '';
      try {
        const config = parseConfigFromUI();
        lastConfig = config;
        // reset caches and charts
        batchCache = {}; lastResultSummaries = null; batchesMeta = null;
        if (avgProfitChart) avgProfitChart.destroy();
        if (balanceChart) balanceChart.destroy();
        runBtnEl.disabled = true; exportBtn.disabled = true;
        statusEl.innerHTML = '<span class="spinner"></span> Running simulation...';
        // create worker and run
        const w = createSimWorker();

        // one-time message handler for final response
        function onMsg(ev) {
          const data = ev.data || {};
          if (data.status === 'error') {
            statusEl.textContent = '';
            resultsContainer.innerHTML = '<p class="error">Simulation error: ' + (data.message || '') + '</p>';
            detailContainer.innerHTML = '<p class="small-text">Fix error and re-run.</p>';
            leaderboardContainer.innerHTML = '<p class="small-text">Fix error and re-run.</p>';
            progressTextEl.textContent = '';
            runBtnEl.disabled = false;
            w.removeEventListener('message', onMsg);
            return;
          }
          if (data.status === 'done') {
            // worker finished — but note: worker keeps full games in its memory; we only receive summaries & batchesMeta
            lastResultSummaries = data.summaries;
            // batchesMeta: array of { gamesCount }
            batchesMeta = (data.batchesMeta || []).map((m) => ({ gamesCount: m.gamesCount }));
            // keep leaderboard (if any)
            // we will request full batches on demand from worker
            renderSummaryTable(lastResultSummaries);
            updateCharts(lastResultSummaries);
            populateBatchSelect(lastResultSummaries);
            renderBatchDetail('0');
            renderLeaderboardFromWorkerData(data.leaderboard, lastConfig);
            statusEl.textContent = 'Done ✔';
            progressTextEl.textContent = '';
            runBtnEl.disabled = false;
            w.removeEventListener('message', onMsg);
            return;
          }
          if (data.status === 'progress') {
            // ignore here (worker has separate listener) but keep progress text
            progressTextEl.textContent = 'Progress: ' + (data.progress || 0) + '%';
            return;
          }
          if (data.status === 'partial') {
            // batch finished; can update partial summary UI if desired
            // not changing main UI aggressively, but update progress text
            progressTextEl.textContent = 'Completed batch ' + (data.batchIndex + 1);
            return;
          }
        }

        // helper to render leaderboard once available
        simWorker.addEventListener('message', function leaderboardListener(ev) {
          const d = ev.data || {};
          if (d && d.status === 'done') {
            // initial done contains leaderboard
            // let main handler process; remove this listener
            simWorker.removeEventListener('message', leaderboardListener);
          }
        });

        simWorker.addEventListener('message', onMsg);

        // start run by posting run message
        simWorker.postMessage({ type: 'run', config: config, _reqId: 'run_' + Date.now() });
      } catch (err) {
        statusEl.textContent = '';
        resultsContainer.innerHTML = `<p class="error">Error: ${err.message}</p>`;
        detailContainer.innerHTML = '<p class="small-text">Fix error and re-run.</p>';
        leaderboardContainer.innerHTML = '<p class="small-text">Fix error and re-run.</p>';
        progressTextEl.textContent = '';
        runBtnEl.disabled = false;
      }
    });

    /* ---------- Render leaderboard from worker-provided object ---------- */
    function renderLeaderboardFromWorkerData(leaderboard, config) {
      if (!leaderboard || !config) {
        leaderboardContainer.innerHTML = `<p class="small-text">No leaderboard data.</p>`; return;
      }
      const pool = leaderboard.pool || 0;
      const scores = leaderboard.scores || [];
      const N = scores.length;
      if (!N || pool <= 0) {
        leaderboardContainer.innerHTML = `<p class="small-text">Leaderboard pool: ${pool.toFixed(2)}.</p>`;
        return;
      }
      const lbTopN = Math.min(config.lbTopN, N);
      const percList = config.lbPrizePercents;
      const perc = []; for (let i = 0; i < lbTopN; i++) perc[i] = typeof percList[i] === 'number' ? percList[i] : 0;

      const players = scores.map((s, idx) => ({ idx, score: s })).sort((a, b) => b.score - a.score);
      let html = `
      <p class="small-text">
        LB Pool: <strong>${pool.toFixed(2)}</strong>
      </p>
      <table><thead><tr>
        <th>Rank</th><th>Player</th><th>Total Winnings</th><th>Prize %</th><th>Prize</th>
      </tr></thead><tbody>`;
      for (let i = 0; i < lbTopN; i++) {
        const p = players[i];
        const pr = pool * (perc[i] / 100);
        html += `<tr>
          <td>${i + 1}</td><td>P${p.idx + 1}</td>
          <td>${p.score.toFixed(2)}</td>
          <td>${perc[i].toFixed(1)}%</td>
          <td>${pr.toFixed(2)}</td>
        </tr>`;
      }
      html += `</tbody></table>`;
      leaderboardContainer.innerHTML = html;
    }

    /* ---------- Reset button ---------- */
    resetBtn.addEventListener('click', () => {
      document.getElementById('entryFee').value = 200;
      document.getElementById('numPlayers').value = 2;
      document.getElementById('baseAdminPct').value = 50;
      document.getElementById('midAdminPct').value = 30;
      document.getElementById('highAdminPct').value = 10;
      document.getElementById('midLossMultiple').value = 3;
      document.getElementById('highLossMultiple').value = 6;
      document.getElementById('lossStreakTrigger').value = 3;
      document.getElementById('winStreakTrigger').value = 3;
      document.getElementById('lossGameMultiple').value = 0.5;
      document.getElementById('bigWinMultiple').value = 1.5;
      document.getElementById('lbReservePct').value = 10;
      document.getElementById('lbTopN').value = 3;
      document.getElementById('lbPrizePercents').value = '50,30,20';
      document.getElementById('gameCounts').value = '100,500,1000,5000';
      document.getElementById('adaptiveRtp').checked = true;

      resultsContainer.innerHTML = '<p class="small-text">Reset to defaults.</p>';
      detailContainer.innerHTML = '<p class="small-text">Run simulation to view details.</p>';
      leaderboardContainer.innerHTML = '<p class="small-text">Run simulation to see leaderboard.</p>';
      statusEl.textContent = '';
      progressTextEl.textContent = '';
      exportBtn.disabled = true;
      batchSelect.innerHTML = '<option value="">No data yet</option>';
      pageInfo.textContent = 'Page 0 / 0';
      if (avgProfitChart) avgProfitChart.destroy();
      if (balanceChart) balanceChart.destroy();
      lastResultSummaries = null;
      batchesMeta = null;
      batchCache = {};
      lastConfig = null;
      // terminate worker if any
      if (simWorker) {
        try { simWorker.terminate(); } catch (e) { }
        simWorker = null;
      }
      runBtnEl.disabled = false;
    });

    /* ---------- Export ---------- */
    exportBtn.addEventListener('click', () => {
      if (lastResultSummaries && lastResultSummaries.length) {
        exportSummaryCSV(lastResultSummaries);
      }
    });

    /* ---------- Batch select change & pagination ---------- */
    batchSelect.addEventListener('change', () => {
      currentPage = 0;
      renderBatchDetail(batchSelect.value);
    });
    pageSizeSelect.addEventListener('change', () => {
      currentPage = 0;
      renderBatchDetail(batchSelect.value);
    });
    prevPageBtn.addEventListener('click', () => {
      if (currentPage > 0) {
        currentPage--;
        renderBatchDetail(batchSelect.value);
      }
    });
    nextPageBtn.addEventListener('click', () => {
      // compute total pages
      if (!batchesMeta || currentBatchIndex == null) return;
      const totalGames = batchesMeta[currentBatchIndex] ? batchesMeta[currentBatchIndex].gamesCount : 0;
      const pageSize = Number(pageSizeSelect.value) || 25;
      const maxPage = Math.max(0, Math.ceil(totalGames / pageSize) - 1);
      if (currentPage < maxPage) {
        currentPage++;
        renderBatchDetail(batchSelect.value);
      }
    });

    /* ---------- Click inside detail container (game button) ---------- */
    detailContainer.addEventListener('click', async (e) => {
      const btn = e.target.closest('.game-link-btn');
      if (!btn) return;
      const globalGameIndex = Number(btn.dataset.gameIndex); // this is index within batch (0-based)
      // we have to request the actual game object from worker for this batch & index
      const bi = currentBatchIndex;
      if (bi == null) return;
      const start = globalGameIndex;
      try {
        const payload = await requestBatchFromWorker(bi, start, 1);
        if (payload && payload.games && payload.games.length) {
          renderGameVisualFromObject(payload.games[0]);
        } else {
          detailContainer.innerHTML = '<p class="error">Could not fetch game details.</p>';
        }
      } catch (err) {
        detailContainer.innerHTML = '<p class="error">Error fetching game: ' + err.message + '</p>';
      }
    });

    /* ---------- Tooltip logic ---------- */
    (function () {
      const tooltip = document.getElementById('configTooltip');
      const titleEl = tooltip.querySelector('.tooltip-title');
      const bodyEl = tooltip.querySelector('.tooltip-body');
      const closeEl = tooltip.querySelector('.tooltip-close');

      function hideTooltip() {
        tooltip.classList.add('hidden');
      }
      function showTooltip(btn) {
        const title = btn.getAttribute('data-title') || 'Info';
        const info = btn.getAttribute('data-info') || '';
        titleEl.textContent = title;
        bodyEl.innerHTML = info.replace(/&#10;/g, '<br/>');

        const rect = btn.getBoundingClientRect();
        const scrollY = window.scrollY || document.documentElement.scrollTop;
        const scrollX = window.scrollX || document.documentElement.scrollLeft;

        let top = rect.bottom + 8 + scrollY;
        let left = rect.left + scrollX;

        tooltip.style.top = top + 'px';
        tooltip.style.left = left + 'px';
        tooltip.classList.remove('hidden');
      }

      document.addEventListener('click', (e) => {
        const infoBtn = e.target.closest('.info-icon');
        const inside = e.target.closest('#configTooltip');
        if (infoBtn) {
          e.stopPropagation();
          showTooltip(infoBtn);
          return;
        }
        if (!inside) {
          hideTooltip();
        }
      });

      closeEl.addEventListener('click', (e) => {
        e.stopPropagation();
        hideTooltip();
      });
    })();

    /* ---------- preserve user's "final file" rule ---------- */
    // You asked me to treat this file as canonical. No functionality removed — only added worker orchestration.
  </script>
</body>

</html>