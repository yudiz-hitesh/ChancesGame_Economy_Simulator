<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chances Game / SNL Economy Simulator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: #0f172a;
      color: #e5e7eb;
    }
    h1, h2 {
      margin-top: 0;
      color: #facc15;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    .card {
      background: #020617;
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.6);
      border: 1px solid #1e293b;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
    }
    label {
      display: block;
      font-size: 13px;
      color: #9ca3af;
      margin-bottom: 4px;
    }
    .label-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    input[type="number"],
    input[type="text"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #334155;
      background: #020617;
      color: #e5e7eb;
      font-size: 14px;
      box-sizing: border-box;
    }
    input[type="number"]:focus,
    input[type="text"]:focus {
      outline: none;
      border-color: #38bdf8;
      box-shadow: 0 0 0 1px #38bdf8;
    }
    .button-row {
      margin-top: 16px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 10px 22px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #020617;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    .btn-secondary {
      background: transparent;
      color: #e5e7eb;
      border: 1px solid #475569;
    }
    .btn-outline {
      background: transparent;
      color: #e5e7eb;
      border: 1px solid #38bdf8;
    }
    .small-text {
      font-size: 12px;
      color: #9ca3af;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #1f2937;
      padding: 6px 8px;
      text-align: right;
    }
    th {
      background: #020617;
      color: #e5e7eb;
      text-align: center;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    td:first-child, th:first-child {
      text-align: left;
    }
    .status {
      font-size: 13px;
      margin-top: 6px;
      color: #a5f3fc;
    }
    .error {
      color: #f97373;
    }
    .spinner {
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 2px solid #38bdf8;
      border-top-color: transparent;
      animation: spin 0.6s linear infinite;
      display: inline-block;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
      margin-top: 10px;
    }
    canvas {
      background: #020617;
      border-radius: 12px;
      padding: 8px;
    }
    select {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #334155;
      background: #020617;
      color: #e5e7eb;
      font-size: 13px;
    }
    .game-link-btn {
      background: transparent;
      border-radius: 999px;
      border: 1px solid #475569;
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
      color: #e5e7eb;
    }
    .game-link-btn:hover {
      border-color: #38bdf8;
    }

    /* --- BOARD (2x size, center) --- */
    .board-grid {
      display: grid;
      grid-template-columns: repeat(10, 64px);
      gap: 4px;
      margin-top: 8px;
      margin-left: auto;
      margin-right: auto;
      justify-content: center;
    }
    .board-cell {
      border-radius: 4px;
      border: 1px solid #1e293b;
      font-size: 11px;
      text-align: center;
      background: #020617;
      color: #6b7280;
      width: 64px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      padding: 0;
      box-sizing: border-box;
    }
    .board-cell.hit {
      background: #166534;
      color: #f9fafb;
      font-weight: 600;
    }
    .board-cell.hit span {
      display: block;
      font-size: 9px;
      color: #bbf7d0;
    }
    .board-tag {
      display: block;
      font-size: 9px;
      margin-top: 1px;
    }
    .board-arrow {
      display: block;
      font-size: 14px;
      line-height: 1;
      margin-top: 0;
    }
    .board-cell.snake-start,
    .board-cell.snake-end {
      background: #7f1d1d;
      color: #fee2e2;
      border-color: #fecaca;
    }
    .board-cell.ladder-start,
    .board-cell.ladder-end {
      background: #facc15;
      color: #4b2e0f; /* brown text */
      border-color: #fcd34d;
    }
    .board-cell.ladder-start.hit,
    .board-cell.ladder-end.hit {
      color: #4b2e0f;
    }
    .board-cell.ladder-start.hit span,
    .board-cell.ladder-end.hit span {
      color: #4b2e0f;
    }

    .game-visual-header {
      margin-top: 8px;
      margin-bottom: 4px;
      font-size: 12px;
      color: #e5e7eb;
    }
    .timeline {
      margin-top: 8px;
      max-height: 160px;
      overflow: auto;
      border-top: 1px solid #1e293b;
      padding-top: 6px;
    }
    .timeline-item {
      font-size: 12px;
      margin-bottom: 2px;
      color: #cbd5f5;
    }

    /* Dice paths */
    .dice-path {
      margin-top: 10px;
      border-top: 1px solid #1e293b;
      padding-top: 6px;
    }
    .dice-player-block {
      margin-top: 8px;
    }
    .dice-player-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 4px;
      color: #e5e7eb;
    }
    .dice-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      margin-top: 2px;
    }
    .dice-table th,
    .dice-table td {
      border: 1px solid #1f2937;
      padding: 4px 6px;
      text-align: center;
    }
    .dice-table th {
      background: #020617;
      position: static;
    }
    .dice-total-row td {
      font-weight: 600;
      background: #020617;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Chances Game / SNL Economy Simulator</h1>
    <p class="small-text">
      Multiplayer Snakes &amp; Ladders economy with adaptive RTP, per-player dice bias and leaderboard pool.
    </p>

    <!-- CONFIG -->
    <div class="card">
      <h2>Configuration</h2>
      <div class="grid">
        <div>
          <label>Entry Fee per Player</label>
          <input id="entryFee" type="number" value="200" min="1" step="1" />
        </div>
        <div>
          <label>Players per Game (2–4)</label>
          <input id="numPlayers" type="number" value="2" min="2" max="4" step="1" />
        </div>
        <div>
          <label>Base Admin % (normal)</label>
          <input id="baseAdminPct" type="number" value="50" min="0" max="90" step="1" />
        </div>
        <div>
          <label>Medium-Loss Admin %</label>
          <input id="midAdminPct" type="number" value="30" min="0" max="90" step="1" />
        </div>
        <div>
          <label>High-Loss Admin %</label>
          <input id="highAdminPct" type="number" value="10" min="0" max="90" step="1" />
        </div>
        <div>
          <label>Medium-Loss Threshold (× entry)</label>
          <input id="midLossMultiple" type="number" value="3" min="0.5" step="0.5" />
        </div>
        <div>
          <label>High-Loss Threshold (× entry)</label>
          <input id="highLossMultiple" type="number" value="6" min="0.5" step="0.5" />
        </div>

        <!-- streak config -->
        <div>
          <label>Loss Streak Size (games)</label>
          <input id="lossStreakTrigger" type="number" value="3" min="1" step="1" />
        </div>
        <div>
          <label>Win Streak Size (games)</label>
          <input id="winStreakTrigger" type="number" value="3" min="1" step="1" />
        </div>
        <div>
          <label>Loss Game Threshold (× entry)</label>
          <input id="lossGameMultiple" type="number" value="0.5" min="0.1" step="0.1" />
        </div>
        <div>
          <label>Big Win Threshold (× entry)</label>
          <input id="bigWinMultiple" type="number" value="1.5" min="0.5" step="0.1" />
        </div>

        <!-- leaderboard from player share -->
        <div>
          <label>Leaderboard Reserve % of Player Share</label>
          <input id="lbReservePct" type="number" value="10" min="0" max="100" step="1" />
        </div>
        <div>
          <label>Leaderboard Top N</label>
          <input id="lbTopN" type="number" value="3" min="1" max="10" step="1" />
        </div>
        <div>
          <label>Leaderboard Prize % per Rank</label>
          <input id="lbPrizePercents" type="text" value="50,30,20" />
        </div>

        <div>
          <label>Game Counts (batches)</label>
          <input id="gameCounts" type="text" value="100,500,1000,5000" />
        </div>

        <div>
          <label>Adaptive RTP / Rescue Mode</label>
          <div>
            <input id="adaptiveRtp" type="checkbox" checked /> <span class="small-text">On</span>
          </div>
        </div>
      </div>

      <div class="button-row">
        <button id="runBtn">▶ Run Simulation</button>
        <button id="resetBtn" class="btn-secondary" type="button">Reset Defaults</button>
        <button id="exportBtn" class="btn-outline" type="button" disabled>⬇ Export Summary CSV</button>
        <span id="status" class="status"></span>
      </div>
    </div>

    <!-- SUMMARY -->
    <div class="card">
      <h2>Summary Results</h2>
      <p class="small-text">One row per batch. Net values are combined for all players.</p>
      <div id="resultsContainer">
        <p class="small-text">No results yet.</p>
      </div>
    </div>

    <!-- DETAILS -->
    <div class="card">
      <h2>Per-Game Detail</h2>
      <p class="small-text">Select batch and click Game # to see board and dice paths.</p>
      <div class="button-row" style="margin-top:0;">
        <label class="small-text">Select Batch:</label>
        <select id="batchSelect">
          <option value="">No data yet</option>
        </select>
      </div>
      <div id="detailContainer" style="margin-top:10px;">
        <p class="small-text">Run a simulation to view details.</p>
      </div>
    </div>

    <!-- CHARTS -->
    <div class="card">
      <h2>Charts</h2>
      <div class="charts-grid">
        <div><canvas id="avgProfitChart" height="200"></canvas></div>
        <div><canvas id="balanceChart" height="200"></canvas></div>
      </div>
    </div>

    <!-- LEADERBOARD -->
    <div class="card">
      <h2>Weekly Leaderboard (Simulated)</h2>
      <div id="leaderboardContainer">
        <p class="small-text">Run simulation to see leaderboard.</p>
      </div>
    </div>
  </div>

  <script>
    /* ---------- Board (Snakes & Ladders) ---------- */
    const LADDERS = [
      { start: 4,  end: 18 },
      { start: 22, end: 42 },
      { start: 35, end: 58 },
      { start: 63, end: 78 },
      { start: 83, end: 96 }
    ];
    const SNAKES = [
      { start: 15, end: 6 },
      { start: 31, end: 14 },
      { start: 38, end: 22 },
      { start: 53, end: 38 },
      { start: 72, end: 40 },
      { start: 93, end: 70 }
    ];

    function createRNG() {
      return { random: () => Math.random() };
    }

    /* ---------- Core Simulation ---------- */
    function runSimulation(config) {
      const ENTRY_FEE   = config.entryFee;
      const N_PLAYERS   = config.numPlayers;
      const adaptiveRtp = config.adaptiveRtp;

      const baseAdminPct = config.baseAdminPct;
      const midAdminPct  = config.midAdminPct;
      const highAdminPct = config.highAdminPct;

      const midLossMultiple  = config.midLossMultiple;
      const highLossMultiple = config.highLossMultiple;

      const lossStreakTrigger = config.lossStreakTrigger;
      const winStreakTrigger  = config.winStreakTrigger;
      const lossGameMultiple  = config.lossGameMultiple;
      const bigWinMultiple    = config.bigWinMultiple;

      const lbReservePct = config.lbReservePct;
      const gameCounts   = config.gameCounts;
      const rng          = createRNG();

      const ladderStarts = new Set(LADDERS.map(l => l.start));
      const snakeStarts  = new Set(SNAKES.map(s => s.start));

      const weights = new Array(101).fill(0);
      const hitProb = new Array(101).fill(0);

      for (let i = 1; i <= 100; i++) {
        if (i >= 1 && i <= 20) {
          weights[i] = 1; hitProb[i] = 0.7;
        } else if (i >= 21 && i <= 60) {
          weights[i] = 2; hitProb[i] = 0.5;
        } else if (i >= 61 && i <= 90) {
          weights[i] = 3; hitProb[i] = 0.3;
        } else if (i >= 91 && i <= 99) {
          weights[i] = 4; hitProb[i] = 0.15;
        } else if (i === 100) {
          weights[i] = 8; hitProb[i] = 0.05;
        }
      }

      // reward boxes: ~25 only, and never on snake/ladder starts
      const candidates = [];
      for (let i = 1; i <= 100; i++) {
        if (hitProb[i] > 0 && !ladderStarts.has(i) && !snakeStarts.has(i)) {
          candidates.push(i);
        }
      }
      const rewardCells = new Set();
      const TARGET_REWARD_BOXES = 25;
      if (candidates.length <= TARGET_REWARD_BOXES) {
        candidates.forEach(i => rewardCells.add(i));
      } else {
        const step = candidates.length / TARGET_REWARD_BOXES;
        for (let k = 0; k < TARGET_REWARD_BOXES; k++) {
          rewardCells.add(candidates[Math.floor(k * step)]);
        }
      }
      for (let i = 1; i <= 100; i++) {
        if (!rewardCells.has(i)) hitProb[i] = 0;
      }

      let activeWeightSum = 0;
      for (let i = 1; i <= 100; i++) {
        if (hitProb[i] > 0) activeWeightSum += weights[i];
      }

      const lifetimeNet = new Array(N_PLAYERS).fill(0);
      const LOSS_WINDOW = 20;
      const recentNets = Array.from({ length: N_PLAYERS }, () => []);

      const lossStreak = new Array(N_PLAYERS).fill(0);
      const winStreak  = new Array(N_PLAYERS).fill(0);

      const LOSS_GAME_NET_THRESHOLD = -lossGameMultiple * ENTRY_FEE;
      const BIG_WIN_NET_THRESHOLD   =  bigWinMultiple * ENTRY_FEE;

      const leaderboardScores = new Array(N_PLAYERS).fill(0);
      let leaderboardPool = 0;

      function applySnakesAndLadders(pos) {
        let dest = pos;
        const ladder = LADDERS.find(l => l.start === dest);
        if (ladder) return { dest: ladder.end, type: 'ladder', idx: LADDERS.indexOf(ladder) };
        const snake = SNAKES.find(s => s.start === dest);
        if (snake) return { dest: snake.end, type: 'snake', idx: SNAKES.indexOf(snake) };
        return { dest, type: null, idx: -1 };
      }

      function simulateBatch(numGames, poolStart, houseStart) {
        let poolBalance  = poolStart;
        let houseBalance = houseStart;

        let totalAdminNet  = 0;
        let totalPlayerNet = 0;
        const gameRows = [];
        const minReward = 1;
        const safetyFactor = 1.5;

        const CAP_FRACTION =
          (N_PLAYERS <= 2) ? 0.8 :
          (N_PLAYERS === 3) ? 0.7 : 0.6;

        for (let g = 1; g <= numGames; g++) {
          const positions = new Array(N_PLAYERS).fill(0);

          let adminPctGame = baseAdminPct;
          if (adaptiveRtp) {
            let worstLossAbs = 0;
            for (let p = 0; p < N_PLAYERS; p++) {
              const arr = recentNets[p];
              let sum = 0;
              for (let k = 0; k < arr.length; k++) sum += arr[k];
              const lossAbs = Math.max(0, -sum);
              worstLossAbs = Math.max(worstLossAbs, lossAbs);
            }
            if (worstLossAbs >= highLossMultiple * ENTRY_FEE)      adminPctGame = highAdminPct;
            else if (worstLossAbs >= midLossMultiple * ENTRY_FEE)  adminPctGame = midAdminPct;
          }

          const playerSharePct = 1 - adminPctGame / 100;
          const totalEntry  = ENTRY_FEE * N_PLAYERS;
          const playerShare = totalEntry * playerSharePct;

          const lbContributionFromPlayers = lbReservePct > 0
            ? playerShare * (lbReservePct / 100)
            : 0;

          const payoutBudget = playerShare - lbContributionFromPlayers;
          const adminBudget  = totalEntry - playerShare;

          let lbContribution = lbContributionFromPlayers;

          poolBalance     += payoutBudget;
          leaderboardPool += lbContributionFromPlayers;
          houseBalance    += adminBudget;

          const baseUnit = activeWeightSum > 0 ? (payoutBudget / activeWeightSum) : 0;

          const boxReward = new Array(101).fill(0);
          for (let i = 1; i <= 100; i++) {
            if (hitProb[i] > 0) {
              boxReward[i] = baseUnit * weights[i] / hitProb[i];
            }
          }
          for (let i = 1; i <= 100; i++) {
            if (boxReward[i] > 0) {
              boxReward[i] = Math.max(minReward, Math.floor(boxReward[i])); // integer
            }
          }
          const remainingReward = boxReward.slice();

          const maxAllowablePayout = safetyFactor > 0 ? (poolBalance / safetyFactor) : poolBalance;
          let globalScale;
          if (maxAllowablePayout >= payoutBudget)      globalScale = 1.0;
          else if (maxAllowablePayout <= 0)           globalScale = 0.1;
          else                                        globalScale = maxAllowablePayout / payoutBudget;

          let totalPayout = 0;
          const events = [];
          const perPlayerRewards = new Array(N_PLAYERS).fill(0);
          const diceStepsByPlayer = Array.from({ length: N_PLAYERS }, () => []);
          let turnCounter = 1;
          let gameOver = false;

          function isLosingPlayer(pIdx) {
            return lossStreak[pIdx] >= lossStreakTrigger;
          }
          function isWinningTooMuch(pIdx) {
            const lifetime = lifetimeNet[pIdx];
            let recentNet = 0;
            const arr = recentNets[pIdx] || [];
            for (let i = 0; i < arr.length; i++) recentNet += arr[i];
            const hotByLifetime = lifetime > 0;
            const hotByRecent   = recentNet >= BIG_WIN_NET_THRESHOLD;
            return (winStreak[pIdx] >= winStreakTrigger) && (hotByLifetime || hotByRecent);
          }
          function simulateDestFrom(pos, d) {
            let tmpPos = pos + d;
            if (tmpPos > 100) tmpPos = 100;
            const snl = applySnakesAndLadders(tmpPos);
            return snl.dest;
          }

          while (!gameOver) {
            for (let p = 0; p < N_PLAYERS; p++) {
              if (gameOver) break;
              let fromPos = positions[p];
              if (fromPos >= 100) continue;

              const randomDice = Math.floor(rng.random() * 6) + 1;
              let finalDice = randomDice;
              let diceReason = '';

              const losing         = isLosingPlayer(p);
              const winningTooMuch = isWinningTooMuch(p);
              const randomDest     = simulateDestFrom(fromPos, randomDice);

              if (adaptiveRtp && losing) {
                let chosen = null; let chosenDest = randomDest;
                for (let d = 1; d <= 6; d++) {
                  const dest = simulateDestFrom(fromPos, d);
                  if (rewardCells.has(dest) && remainingReward[dest] > 0) {
                    chosen = d; chosenDest = dest; break;
                  }
                }
                if (chosen !== null && chosen !== randomDice) {
                  finalDice = chosen;
                  diceReason = `Random dice was ${randomDice}, changed to ${finalDice} to help recovery towards reward box ${chosenDest}.`;
                } else {
                  diceReason = `Random dice ${randomDice} used as-is.`;
                }
              } else if (adaptiveRtp && winningTooMuch) {
                const destIsReward = rewardCells.has(randomDest) && remainingReward[randomDest] > 0;
                if (destIsReward) {
                  let alt = null; let altDest = randomDest;
                  for (let d = 1; d <= 6; d++) {
                    const dest = simulateDestFrom(fromPos, d);
                    if (!rewardCells.has(dest) || remainingReward[dest] <= 0) {
                      alt = d; altDest = dest; break;
                    }
                  }
                  if (alt !== null && alt !== randomDice) {
                    finalDice = alt;
                    diceReason = `Random dice was ${randomDice} (reward), changed to ${finalDice} to limit extra win (landed on ${altDest}).`;
                  } else {
                    diceReason = `Random dice ${randomDice} used as-is (no safe alternative).`;
                  }
                } else {
                  diceReason = `Random dice ${randomDice} used as-is (player already in profit, but no instant reward).`;
                }
              } else {
                diceReason = `Random dice ${randomDice} used as-is.`;
              }

              let stepPos = fromPos + finalDice;
              if (stepPos > 100) stepPos = 100;
              let snlInfo = applySnakesAndLadders(stepPos);
              let toPos = snlInfo.dest;

              let snlNote = '';
              if (snlInfo.type === 'ladder') snlNote = ` Climbed Ladder ${snlInfo.idx + 1}: ${stepPos} → ${toPos}.`;
              else if (snlInfo.type === 'snake') snlNote = ` Bitten by Snake ${snlInfo.idx + 1}: ${stepPos} → ${toPos}.`;

              positions[p] = toPos;

              let reward = 0;
              if (rewardCells.has(toPos) && remainingReward[toPos] > 0) {
                let baseRemaining = remainingReward[toPos];
                let boxPay = 0;
                if (baseRemaining > 0) {
                  boxPay = Math.floor(baseRemaining * globalScale);
                  if (boxPay < minReward) boxPay = minReward;
                }
                if (boxPay > poolBalance) boxPay = Math.floor(poolBalance);
                if (boxPay > 0) {
                  // cap per-game max share for this player
                  const projectedTotal = totalPayout + boxPay;
                  const playerCap = CAP_FRACTION * projectedTotal;
                  let capacity = playerCap - perPlayerRewards[p];
                  if (capacity < 0) capacity = 0;
                  let give = Math.min(boxPay, capacity, poolBalance);
                  give = Math.floor(give); // integer
                  if (give > 0) {
                    poolBalance -= give;
                    perPlayerRewards[p] += give;
                    leaderboardScores[p] += give;
                    totalPayout += give;
                    remainingReward[toPos] -= give;
                    if (remainingReward[toPos] < 0) remainingReward[toPos] = 0;

                    reward += give;
                    events.push({
                      boxIndex: toPos,
                      rewardGiven: give,
                      poolBefore: poolBalance + give,
                      poolAfter: poolBalance,
                      playerIndex: p
                    });
                  }
                }
              }

              const noteFull = diceReason + snlNote;
              diceStepsByPlayer[p].push({
                turn: turnCounter++,
                randomDice,
                finalDice,
                from: fromPos,
                to: toPos,
                reward,
                note: noteFull
              });

              if (toPos >= 100) { gameOver = true; break; }
            }
          }

          const perPlayerNet = perPlayerRewards.map(r => r - ENTRY_FEE);
          const playerNet = perPlayerNet.reduce((a,b) => a + b, 0);

          // update streaks
          for (let p = 0; p < N_PLAYERS; p++) {
            const net = perPlayerNet[p];
            if (net <= LOSS_GAME_NET_THRESHOLD) {
              lossStreak[p] += 1; winStreak[p] = 0;
            } else if (net >= BIG_WIN_NET_THRESHOLD) {
              winStreak[p] += 1;  lossStreak[p] = 0;
            } else {
              lossStreak[p] = 0;  winStreak[p] = 0;
            }
          }

          let adminNet = totalEntry - totalPayout;
          totalPlayerNet += playerNet;
          totalAdminNet  += adminNet;

          for (let p = 0; p < N_PLAYERS; p++) {
            lifetimeNet[p] += perPlayerNet[p];
            const arr = recentNets[p];
            arr.push(perPlayerNet[p]);
            if (arr.length > LOSS_WINDOW) arr.shift();
          }

          gameRows.push({
            gameNo: g,
            totalEntry,
            payoutBudget,
            adminBudget,
            totalPayout,
            perPlayerRewards,
            perPlayerNet,
            playerNet,
            adminNet,
            lbContribution,
            adminPctUsed: adminPctGame,
            poolAfter: poolBalance,
            houseAfter: houseBalance,
            globalScale,
            events,
            diceSteps: diceStepsByPlayer
          });
        }

        return {
          poolBalance,
          houseBalance,
          totalAdminNet,
          totalPlayerNet,
          avgAdminPerGame: totalAdminNet / numGames,
          avgPlayerPerGame: totalPlayerNet / numGames,
          games: gameRows
        };
      }

      let pool = 0, house = 0;
      const summaries = [];
      const batches = [];

      for (const c of gameCounts) {
        const nGames = c;
        const res = simulateBatch(nGames, pool, house);
        pool  = res.poolBalance;
        house = res.houseBalance;

        summaries.push({
          games: nGames,
          totalAdminNet: res.totalAdminNet,
          totalPlayerNet: res.totalPlayerNet,
          avgAdminPerGame: res.avgAdminPerGame,
          avgPlayerPerGame: res.avgPlayerPerGame,
          poolAfter: pool,
          houseAfter: house,
          leaderboardPoolAfter: leaderboardPool
        });

        batches.push({ gamesCount: nGames, games: res.games });
      }

      return { summaries, batches, leaderboard: { pool: leaderboardPool, scores: leaderboardScores } };
    }

    /* ---------- UI wiring ---------- */
    const runBtnEl  = document.getElementById('runBtn');
    const resetBtn  = document.getElementById('resetBtn');
    const exportBtn = document.getElementById('exportBtn');
    const statusEl  = document.getElementById('status');
    const resultsContainer = document.getElementById('resultsContainer');
    const batchSelect = document.getElementById('batchSelect');
    const detailContainer = document.getElementById('detailContainer');
    const leaderboardContainer = document.getElementById('leaderboardContainer');

    let lastResult = null;
    let lastConfig = null;
    let avgProfitChart = null;
    let balanceChart   = null;

    function parseConfigFromUI() {
      const val = id => Number(document.getElementById(id).value);
      const entryFee   = val('entryFee');
      const numPlayers = val('numPlayers');
      const baseAdminPct = val('baseAdminPct');
      const midAdminPct  = val('midAdminPct');
      const highAdminPct = val('highAdminPct');
      const midLossMultiple  = val('midLossMultiple');
      const highLossMultiple = val('highLossMultiple');
      const lossStreakTrigger = val('lossStreakTrigger');
      const winStreakTrigger  = val('winStreakTrigger');
      const lossGameMultiple  = val('lossGameMultiple');
      const bigWinMultiple    = val('bigWinMultiple');
      const lbReservePct = val('lbReservePct');
      const lbTopN       = val('lbTopN');
      const lbPrizeStr   = document.getElementById('lbPrizePercents').value;
      const gameCountsStr = document.getElementById('gameCounts').value;
      const adaptiveRtp   = document.getElementById('adaptiveRtp').checked;

      const gameCounts = gameCountsStr.split(',')
        .map(s => Number(s.trim()))
        .filter(n => !isNaN(n) && n > 0);

      if (!entryFee || entryFee <= 0) throw new Error("Entry fee must be > 0");
      if (numPlayers < 2 || numPlayers > 4) throw new Error("Players per game must be 2–4");
      if (!gameCounts.length) throw new Error("Game counts missing");

      if (highLossMultiple < midLossMultiple) throw new Error("High-Loss threshold ≥ Medium-Loss required");

      const lbPrizePercents = lbPrizeStr.split(',')
        .map(s => Number(s.trim()))
        .filter(n => !isNaN(n) && n >= 0);
      if (!lbPrizePercents.length) throw new Error("LB prize % invalid");

      return {
        entryFee, numPlayers, adaptiveRtp,
        baseAdminPct, midAdminPct, highAdminPct,
        midLossMultiple, highLossMultiple,
        lossStreakTrigger, winStreakTrigger,
        lossGameMultiple, bigWinMultiple,
        lbReservePct, lbTopN, lbPrizePercents,
        gameCounts
      };
    }

    function renderSummaryTable(summaries) {
      if (!summaries.length) {
        resultsContainer.innerHTML = `<p class="small-text">No data.</p>`;
        exportBtn.disabled = true;
        return;
      }
      let html = `
      <table>
        <thead>
          <tr>
            <th>Games</th>
            <th>Total Admin Net</th>
            <th>Total Player Net</th>
            <th>Avg Admin/Game</th>
            <th>Avg Player/Game</th>
            <th>Pool After</th>
            <th>House After</th>
            <th>LB Pool After</th>
          </tr>
        </thead><tbody>`;
      summaries.forEach(s => {
        html += `<tr>
          <td>${s.games}</td>
          <td>${s.totalAdminNet.toFixed(2)}</td>
          <td>${s.totalPlayerNet.toFixed(2)}</td>
          <td>${s.avgAdminPerGame.toFixed(2)}</td>
          <td>${s.avgPlayerPerGame.toFixed(2)}</td>
          <td>${s.poolAfter.toFixed(2)}</td>
          <td>${s.houseAfter.toFixed(2)}</td>
          <td>${(s.leaderboardPoolAfter||0).toFixed(2)}</td>
        </tr>`;
      });
      html += `</tbody></table>`;
      resultsContainer.innerHTML = html;
      exportBtn.disabled = false;
    }

    function updateCharts(summaries) {
      if (!summaries.length) return;
      const labels = summaries.map(s => s.games.toString());
      const avgAdmin  = summaries.map(s => s.avgAdminPerGame);
      const avgPlayer = summaries.map(s => s.avgPlayerPerGame);
      const poolAfter = summaries.map(s => s.poolAfter);
      const houseAfter= summaries.map(s => s.houseAfter);

      const avgCtx = document.getElementById('avgProfitChart').getContext('2d');
      const balCtx = document.getElementById('balanceChart').getContext('2d');
      if (avgProfitChart) avgProfitChart.destroy();
      if (balanceChart)   balanceChart.destroy();

      avgProfitChart = new Chart(avgCtx, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            { label: 'Avg Admin/Game', data: avgAdmin },
            { label: 'Avg Player/Game', data: avgPlayer }
          ]
        },
        options: {
          responsive:true,
          plugins:{ legend:{ labels:{ color:'#e5e7eb' } } },
          scales:{ x:{ ticks:{ color:'#e5e7eb'} }, y:{ ticks:{ color:'#e5e7eb'} } }
        }
      });

      balanceChart = new Chart(balCtx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label:'Pool After',  data: poolAfter },
            { label:'House After', data: houseAfter }
          ]
        },
        options:{
          responsive:true,
          plugins:{ legend:{ labels:{ color:'#e5e7eb'} } },
          scales:{ x:{ ticks:{ color:'#e5e7eb'} }, y:{ ticks:{ color:'#e5e7eb'} } }
        }
      });
    }

    function populateBatchSelect(result) {
      const summaries = result.summaries;
      batchSelect.innerHTML = '';
      if (!summaries.length) {
        batchSelect.innerHTML = '<option value="">No data yet</option>';
        return;
      }
      summaries.forEach((s,idx)=>{
        const o=document.createElement('option');
        o.value=String(idx); o.textContent=`${s.games} games`;
        batchSelect.appendChild(o);
      });
    }

    function renderBatchDetail(index) {
      if (!lastResult || !lastResult.batches || index==null || index==='') {
        detailContainer.innerHTML = `<p class="small-text">Select a batch.</p>`; return;
      }
      const batch = lastResult.batches[Number(index)];
      if (!batch) { detailContainer.innerHTML = `<p class="small-text">No data.</p>`; return; }
      const games = batch.games;
      if (!games.length) { detailContainer.innerHTML = `<p class="small-text">No games.</p>`; return; }

      const N = lastConfig ? lastConfig.numPlayers : 0;
      const fmt = (r,i)=> (i<N && r && typeof r[i]==='number') ? r[i].toFixed(2) : '-';

      let html = `
      <div class="small-text">Showing ${games.length} games. Click Game #.</div>
      <div style="max-height:260px;overflow:auto;">
      <table><thead>
        <tr>
          <th>Game #</th>
          <th>Total Entry</th>
          <th>Total Payout</th>
          <th>P1 Reward</th><th>P2 Reward</th><th>P3 Reward</th><th>P4 Reward</th>
          <th>Admin %</th><th>Admin Net</th>
          <th>LB Reserve</th><th>Pool After</th><th>House After</th><th>Scale</th>
        </tr></thead><tbody>`;
      games.forEach((g,idx)=>{
        const r=g.perPlayerRewards||[];
        html += `<tr>
          <td><button class="game-link-btn" data-game-index="${idx}">${g.gameNo}</button></td>
          <td>${g.totalEntry.toFixed(2)}</td>
          <td>${g.totalPayout.toFixed(2)}</td>
          <td>${fmt(r,0)}</td><td>${fmt(r,1)}</td><td>${fmt(r,2)}</td><td>${fmt(r,3)}</td>
          <td>${(g.adminPctUsed||0).toFixed(1)}</td>
          <td>${g.adminNet.toFixed(2)}</td>
          <td>${(g.lbContribution||0).toFixed(2)}</td>
          <td>${g.poolAfter.toFixed(2)}</td>
          <td>${g.houseAfter.toFixed(2)}</td>
          <td>${g.globalScale.toFixed(3)}</td>
        </tr>`;
      });
      html += `</tbody></table></div>
        <div id="gameVisual" class="small-text" style="margin-top:10px;">
          Click a Game # to see board and dice paths.
        </div>`;
      detailContainer.innerHTML = html;
    }

    function renderGameVisual(batchIndex, gameIndex) {
      if (!lastResult || !lastResult.batches) return;
      const batch = lastResult.batches[batchIndex];
      if (!batch) return;
      const game = batch.games[gameIndex];
      if (!game) return;

      const events = game.events||[];
      const eventMap={};
      events.forEach(ev=>{ eventMap[ev.boxIndex]=ev; });

      let perPlayerSummary='';
      if (lastConfig && game.perPlayerRewards) {
        const N=lastConfig.numPlayers;
        const labels=[];
        for(let i=0;i<N;i++){
          const val=game.perPlayerRewards[i]||0;
          const net=game.perPlayerNet?game.perPlayerNet[i]||0:0;
          labels.push(`P${i+1}: reward ${val.toFixed(2)}, net ${net.toFixed(2)}`);
        }
        perPlayerSummary=' | '+labels.join(' | ');
      }

      let html = `
        <div class="game-visual-header">
          <strong>Game #${game.gameNo}</strong> — Entry: ${game.totalEntry.toFixed(2)},
          Payout: ${game.totalPayout.toFixed(2)}, Admin Net: ${game.adminNet.toFixed(2)},
          Player Net: ${game.playerNet.toFixed(2)}${perPlayerSummary}
          <br/>Admin %: ${(game.adminPctUsed||0).toFixed(1)}%, Scale: ${game.globalScale.toFixed(3)},
          Pool after: ${game.poolAfter.toFixed(2)}, LB Reserve: ${(game.lbContribution||0).toFixed(2)}
        </div>
        <div class="board-grid">`;

      for(let box=1;box<=100;box++){
        const ev=eventMap[box];
        let classes='board-cell';
        let tag=''; let arrow='';

        const liStart=LADDERS.findIndex(l=>l.start===box);
        const liEnd  =LADDERS.findIndex(l=>l.end===box);
        const siStart=SNAKES.findIndex(s=>s.start===box);
        const siEnd  =SNAKES.findIndex(s=>s.end===box);

        if (liStart>=0){ classes+=' ladder-start'; tag=`L${liStart+1}-Start`; arrow='↑'; }
        else if(liEnd>=0){ classes+=' ladder-end'; tag=`L${liEnd+1}-End`; arrow='▲'; }
        if (siStart>=0){ classes+=' snake-start'; tag=`S${siStart+1}-Start`; arrow='↓'; }
        else if(siEnd>=0){ classes+=' snake-end'; tag=`S${siEnd+1}-End`; arrow='▼'; }

        if (ev) classes+=' hit';

        html += `<div class="${classes}">
          ${box}
          ${arrow?`<span class="board-arrow">${arrow}</span>`:''}
          ${tag?`<span class="board-tag">${tag}</span>`:''}
          ${ev?`<span>+${ev.rewardGiven}</span>`:''}
        </div>`;
      }
      html += `</div>`;

      html += `<div class="timeline">`;
      if (!events.length){
        html += `<div class="timeline-item">No rewards in this game.</div>`;
      } else {
        events.forEach((ev,idx)=>{
          const pid = (typeof ev.playerIndex==='number') ? `P${ev.playerIndex+1}: ` : '';
          html += `<div class="timeline-item">
            Step ${idx+1}: ${pid}Box ${ev.boxIndex} → +${ev.rewardGiven}
            (Pool: ${ev.poolBefore.toFixed(0)} → ${ev.poolAfter.toFixed(0)})
          </div>`;
        });
      }
      html += `</div>`;

      // dice paths
      html += `<div class="dice-path">`;
      if (!lastConfig || !game.diceSteps){
        html += `<div class="timeline-item">No dice data.</div>`;
      } else {
        const N=lastConfig.numPlayers;
        for(let p=0;p<N;p++){
          const steps=game.diceSteps[p]||[];
          if (!steps.length) continue;
          let totalReward=0;
          html += `<div class="dice-player-block">
            <div class="dice-player-title">Dice Path for Player P${p+1}</div>
            <table class="dice-table">
              <thead><tr>
                <th>Turn</th><th>Random Dice</th><th>Final Dice</th>
                <th>From</th><th>To</th><th>Reward</th><th>Note</th>
              </tr></thead><tbody>`;
          steps.forEach(s=>{
            totalReward+=s.reward;
            html += `<tr>
              <td>${s.turn}</td><td>${s.randomDice}</td><td>${s.finalDice}</td>
              <td>${s.from}</td><td>${s.to}</td>
              <td>${s.reward.toFixed(0)}</td>
              <td style="text-align:left;">${s.note}</td>
            </tr>`;
          });
          html += `<tr class="dice-total-row">
            <td colspan="5" style="text-align:right;">Total Reward</td>
            <td>${totalReward.toFixed(0)}</td><td></td>
          </tr>`;
          html += `</tbody></table></div>`;
        }
      }
      html += `</div>`;

      const gv=document.getElementById('gameVisual');
      if (gv) gv.innerHTML = html;
    }

    function renderLeaderboard(result, config) {
      if (!result || !result.leaderboard || !config) {
        leaderboardContainer.innerHTML=`<p class="small-text">No leaderboard data.</p>`; return;
      }
      const pool = result.leaderboard.pool||0;
      const scores = result.leaderboard.scores||[];
      const N = scores.length;
      if (!N || pool<=0){
        leaderboardContainer.innerHTML=`<p class="small-text">Leaderboard pool: ${pool.toFixed(2)}.</p>`;
        return;
      }
      const lbTopN = Math.min(config.lbTopN, N);
      const percList=config.lbPrizePercents;
      const perc=[]; for(let i=0;i<lbTopN;i++) perc[i]=typeof percList[i]==='number'?percList[i]:0;

      const players=scores.map((s,idx)=>({idx,score:s})).sort((a,b)=>b.score-a.score);
      let html = `
      <p class="small-text">
        LB Pool: <strong>${pool.toFixed(2)}</strong>
      </p>
      <table><thead><tr>
        <th>Rank</th><th>Player</th><th>Total Winnings</th><th>Prize %</th><th>Prize</th>
      </tr></thead><tbody>`;
      for(let i=0;i<lbTopN;i++){
        const p=players[i];
        const pr=pool*(perc[i]/100);
        html += `<tr>
          <td>${i+1}</td><td>P${p.idx+1}</td>
          <td>${p.score.toFixed(2)}</td>
          <td>${perc[i].toFixed(1)}%</td>
          <td>${pr.toFixed(2)}</td>
        </tr>`;
      }
      html += `</tbody></table>`;
      leaderboardContainer.innerHTML = html;
    }

    function exportSummaryCSV(summaries){
      if(!summaries.length) return;
      const header=[
        'Games_Simulated','Total_Admin_Net','Total_Player_Net',
        'Avg_Admin_per_Game','Avg_Player_per_Game',
        'PoolAfter','HouseAfter','LBPoolAfter'
      ];
      const rows=summaries.map(s=>[
        s.games,
        s.totalAdminNet.toFixed(2),
        s.totalPlayerNet.toFixed(2),
        s.avgAdminPerGame.toFixed(2),
        s.avgPlayerPerGame.toFixed(2),
        s.poolAfter.toFixed(2),
        s.houseAfter.toFixed(2),
        (s.leaderboardPoolAfter||0).toFixed(2)
      ]);
      let csv = header.join(',')+'\n';
      rows.forEach(r=>{ csv += r.join(',')+'\n'; });
      const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a');
      a.href=url; a.download='snl_economy_summary.csv'; a.click();
      URL.revokeObjectURL(url);
    }

    runBtnEl.addEventListener('click', () => {
      statusEl.textContent=''; resultsContainer.innerHTML='';
      detailContainer.innerHTML='<p class="small-text">Running...</p>';
      leaderboardContainer.innerHTML='<p class="small-text">Running...</p>';
      try{
        const config=parseConfigFromUI();
        lastConfig=config;
        runBtnEl.disabled=true; exportBtn.disabled=true;
        statusEl.innerHTML='<span class="spinner"></span> Running simulation...';
        setTimeout(()=>{
          lastResult=runSimulation(config);
          renderSummaryTable(lastResult.summaries);
          updateCharts(lastResult.summaries);
          populateBatchSelect(lastResult);
          renderBatchDetail(batchSelect.value||'0');
          renderLeaderboard(lastResult,lastConfig);
          statusEl.textContent='Done ✔';
          runBtnEl.disabled=false;
        },20);
      }catch(err){
        statusEl.textContent='';
        resultsContainer.innerHTML=`<p class="error">Error: ${err.message}</p>`;
        detailContainer.innerHTML='<p class="small-text">Fix error and re-run.</p>';
        leaderboardContainer.innerHTML='<p class="small-text">Fix error and re-run.</p>';
      }
    });

    resetBtn.addEventListener('click',()=>{
      document.getElementById('entryFee').value=200;
      document.getElementById('numPlayers').value=2;
      document.getElementById('baseAdminPct').value=50;
      document.getElementById('midAdminPct').value=30;
      document.getElementById('highAdminPct').value=10;
      document.getElementById('midLossMultiple').value=3;
      document.getElementById('highLossMultiple').value=6;
      document.getElementById('lossStreakTrigger').value=3;
      document.getElementById('winStreakTrigger').value=3;
      document.getElementById('lossGameMultiple').value=0.5;
      document.getElementById('bigWinMultiple').value=1.5;
      document.getElementById('lbReservePct').value=10;
      document.getElementById('lbTopN').value=3;
      document.getElementById('lbPrizePercents').value='50,30,20';
      document.getElementById('gameCounts').value='100,500,1000,5000';
      document.getElementById('adaptiveRtp').checked=true;

      resultsContainer.innerHTML='<p class="small-text">Reset to defaults.</p>';
      detailContainer.innerHTML='<p class="small-text">Run simulation to view details.</p>';
      leaderboardContainer.innerHTML='<p class="small-text">Run simulation to see leaderboard.</p>';
      statusEl.textContent='';
      exportBtn.disabled=true;
      batchSelect.innerHTML='<option value="">No data yet</option>';
      if(avgProfitChart) avgProfitChart.destroy();
      if(balanceChart) balanceChart.destroy();
      lastResult=null; lastConfig=null;
    });

    exportBtn.addEventListener('click',()=>{
      if(lastResult && lastResult.summaries && lastResult.summaries.length){
        exportSummaryCSV(lastResult.summaries);
      }
    });

    batchSelect.addEventListener('change',()=>{
      renderBatchDetail(batchSelect.value);
    });

    detailContainer.addEventListener('click',(e)=>{
      const btn=e.target.closest('.game-link-btn');
      if(!btn) return;
      const gi=Number(btn.dataset.gameIndex);
      const bi=Number(batchSelect.value||0);
      renderGameVisual(bi,gi);
    });
  </script>
</body>
</html>
